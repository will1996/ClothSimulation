!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
AUGLAG_HPP	auglag.hpp	3;"	d
AttachHandle	handle.hpp	/^struct AttachHandle : public Handle {$/;"	s
BOX	tmbvh.hpp	142;"	d
Bary	separateobs.cpp	/^typedef Vec3 Bary; \/\/ barycentric coordinates$/;"	t	namespace:SO	file:
BendingData	dde.hpp	/^struct BendingData { REAL d[3][5]; };$/;"	s
BodyFrame	mot_parser.hpp	/^struct BodyFrame$/;"	s
BodyFrameVector	mot_parser.hpp	/^typedef std::vector<BodyFrame> BodyFrameVector;$/;"	t
BodyVector	mot_parser.hpp	/^typedef std::vector<BodyFrameVector> BodyVector;$/;"	t
Box	conf.cpp	/^    Box () {}$/;"	f	struct:Box
Box	conf.cpp	/^    Box (const Vec2 &umin, const Vec2 &umax): umin(umin), umax(umax) {}$/;"	f	struct:Box
Box	conf.cpp	/^struct Box {$/;"	s	file:
CalculateFrameRate	main.cpp	/^void CalculateFrameRate()$/;"	f
CaptureScreen	main.cpp	/^void CaptureScreen(int Width, int Height)$/;"	f
CircleHandle	handle.hpp	/^struct CircleHandle : public Handle {$/;"	s
Cloth	cloth.hpp	/^struct Cloth {$/;"	s
Collision	simulation.hpp	/^		Proximity, Physics, StrainLimiting, Collision, Remeshing, Separation,$/;"	e	enum:Simulation::__anon5
Constraint	constraint.hpp	/^struct Constraint {$/;"	s
DISP_SCALE	main.cpp	/^float DISP_SCALE = 0.001f;$/;"	v
DTransformation	transformation.hpp	/^typedef std::pair<Transformation, Transformation> DTransformation;$/;"	t
Dm	mesh.hpp	/^	Mat2x2 Dm, invDm; \/\/ finite element matrix$/;"	m	struct:Face
ECHO	util.hpp	144;"	d
EPSILON	util.hpp	15;"	d
Edge	mesh.hpp	/^	Edge() {}$/;"	f	struct:Edge
Edge	mesh.hpp	/^	explicit Edge(Node *node0, Node *node1, REAL theta_ideal, int label = 0) :$/;"	f	struct:Edge
Edge	mesh.hpp	/^	explicit Edge(Node *node0, Node *node1, int label = 0) :$/;"	f	struct:Edge
Edge	mesh.hpp	/^struct Edge {$/;"	s
Eig	vectors.hpp	/^template <int n> struct Eig {$/;"	s
EigenSpMat	eigen.cpp	/^typedef SparseMatrix<REAL> EigenSpMat;$/;"	t	file:
EigenVec	eigen.cpp	/^typedef VectorXd EigenVec;$/;"	t	file:
EigenVec	eigen.cpp	/^typedef VectorXf EigenVec;$/;"	t	file:
EqCon	constraint.hpp	/^struct EqCon : public Constraint {$/;"	s
FORCEINLINE	util.hpp	12;"	d
Face	mesh.hpp	/^	Face() {}$/;"	f	struct:Face
Face	mesh.hpp	/^	explicit Face(Vert *vert0, Vert *vert1, Vert *vert2, int label = 0) :$/;"	f	struct:Face
Face	mesh.hpp	/^struct Face {$/;"	s
GPUTimer2	timer.hpp	/^	GPUTimer2() :accum(0) {$/;"	f	struct:GPUTimer2
GPUTimer2	timer.hpp	/^struct GPUTimer2 {$/;"	s
GlueCon	constraint.hpp	/^struct GlueCon : public Constraint {$/;"	s
GlueHandle	handle.hpp	/^struct GlueHandle : public Handle {$/;"	s
Handle	handle.hpp	/^struct Handle {$/;"	s
I_EE	collision.cpp	/^	I_EE = 1$/;"	e	enum:__anon1	file:
I_NULL	collision.cpp	/^	I_NULL = -1,$/;"	e	enum:__anon1	file:
I_VF	collision.cpp	/^	I_VF = 0,$/;"	e	enum:__anon1	file:
ImpactType	collision.cpp	/^} ImpactType;$/;"	t	typeref:enum:__anon1	file:
IneqCon	constraint.hpp	/^struct IneqCon : public Constraint {$/;"	s
Interp	handle.cpp	/^inline Vec3 Interp(Vec3 &x0, Vec3 &x1, REAL w)$/;"	f
Ixn	separateobs.cpp	/^    Ixn () {}$/;"	f	struct:SO::Ixn
Ixn	separateobs.cpp	/^    Ixn (const Face *f0, const Bary &b0, const Face *f1, const Bary &b1,$/;"	f	struct:SO::Ixn
Ixn	separateobs.cpp	/^struct Ixn {\/\/ intersection$/;"	s	namespace:SO	file:
J	popfilter.cpp	/^    mutable SpMat<Mat3x3> J;$/;"	m	struct:PopOpt	file:
LineTriangleIntersect	gpu.cpp	/^LineTriangleIntersect(Vec3 &start, Vec3 &end, Vec3 &v0, Vec3 &v1, Vec3 &v2)$/;"	f
MAX	tmbvh.hpp	140;"	d
MIN	tmbvh.hpp	141;"	d
Magic	magic.hpp	/^	Magic() :$/;"	f	struct:Magic
Magic	magic.hpp	/^struct Magic {$/;"	s
Mat	vectors.hpp	/^    Mat () {for (int j = 0; j < n; j++) c[j] = VecmT(0);}$/;"	f	class:Mat
Mat	vectors.hpp	/^    explicit Mat (T x) {for (int j = 0; j < n; j++) {c[j] = VecmT(0); if (j < m) c[j][j] = x;}}$/;"	f	class:Mat
Mat	vectors.hpp	/^    explicit Mat (VecmT x, VecmT y) {static_assert(n==2); c[0] = x; c[1] = y;}$/;"	f	class:Mat
Mat	vectors.hpp	/^    explicit Mat (VecmT x, VecmT y, VecmT z) {static_assert(n==3); c[0] = x; c[1] = y; c[2] = z;}$/;"	f	class:Mat
Mat	vectors.hpp	/^    explicit Mat (VecmT x, VecmT y, VecmT z, VecmT w) {static_assert(n==4); c[0] = x; c[1] = y; c[2] = z; c[3] = w;}$/;"	f	class:Mat
Mat	vectors.hpp	/^template <int m, int n, typename T=REAL> class Mat {$/;"	c
Mat2x2	vectors.hpp	/^typedef Mat<2,2> Mat2x2;$/;"	t
Mat2x3	vectors.hpp	/^typedef Mat<2,3> Mat2x3;$/;"	t
Mat3x2	vectors.hpp	/^typedef Mat<3,2> Mat3x2;$/;"	t
Mat3x3	vectors.hpp	/^typedef Mat<3,3> Mat3x3;$/;"	t
MatTransposed	vectors.hpp	/^template <int m, int n, typename T> class MatTransposed : protected Mat<m,n,T> {$/;"	c
Material	cloth.hpp	/^	struct Material {$/;"	s	struct:Cloth
MatmnT	vectors.hpp	117;"	d
MatmnT	vectors.hpp	184;"	d
MatnmT	vectors.hpp	118;"	d
MatnnT	vectors.hpp	119;"	d
MatnnT	vectors.hpp	185;"	d
Mesh	mesh.hpp	/^	Mesh() {$/;"	f	struct:Mesh
Mesh	mesh.hpp	/^struct Mesh {$/;"	s
MeshGrad	constraint.hpp	/^typedef std::map<Node*, Vec3> MeshGrad;$/;"	t
MeshHess	constraint.hpp	/^typedef std::map<std::pair<Node*, Node*>, Mat3x3> MeshHess;$/;"	t
Morph	morph.hpp	/^struct Morph {$/;"	s
Motion	transformation.hpp	/^typedef Spline<Transformation> Motion;$/;"	t
NEXT	util.hpp	19;"	d
NLConOpt	optimization.hpp	/^struct NLConOpt { \/\/ nonlinear constrained optimization problem$/;"	s
NLOpt	auglag.hpp	/^struct NLOpt { \/\/ nonlinear optimization problem$/;"	s
NLOpt	optimization.hpp	/^struct NLOpt { \/\/ nonlinear optimization problem$/;"	s
NO_UI	main.cpp	410;"	d	file:
Node	mesh.hpp	/^	Node() {}$/;"	f	struct:Node
Node	mesh.hpp	/^	explicit Node(const Vec3 &x, const Vec3 &v, int label = 0) :$/;"	f	struct:Node
Node	mesh.hpp	/^	explicit Node(const Vec3 &x, int label = 0) :$/;"	f	struct:Node
Node	mesh.hpp	/^	explicit Node(const Vec3 &y, const Vec3 &x, const Vec3 &v, int label = 0) :$/;"	f	struct:Node
Node	mesh.hpp	/^struct Node {$/;"	s
NodeHandle	handle.hpp	/^	NodeHandle() : activated(false) {}$/;"	f	struct:NodeHandle
NodeHandle	handle.hpp	/^struct NodeHandle : public Handle {$/;"	s
OBJ_FILE	strainlimiting.cpp	363;"	d	file:
ONE_PASS_CD	gpu.cpp	8;"	d	file:
OPTIMIZATION_HPP	optimization.hpp	3;"	d
Obstacle	obstacle.hpp	/^	Obstacle() : start_time(0), end_time(infinity), activated(false) {}$/;"	f	struct:Obstacle
Obstacle	obstacle.hpp	/^struct Obstacle {$/;"	s
OptOptions	optimization.hpp	/^    OptOptions (): _max_iter(100), _eps_x(1e-6), _eps_f(1e-12), _eps_g(1e-6) {}$/;"	f	struct:OptOptions
OptOptions	optimization.hpp	/^struct OptOptions {$/;"	s
PARSE_MAGIC	conf.cpp	553;"	d	file:
PARSE_MAGIC	conf.cpp	573;"	d	file:
POPFILTER_HPP	popfilter.hpp	3;"	d
PREV	util.hpp	20;"	d
PS	geometry.hpp	/^enum Space {PS, WS}; \/\/ plastic space, world space$/;"	e	enum:Space
Physics	simulation.hpp	/^		Proximity, Physics, StrainLimiting, Collision, Remeshing, Separation,$/;"	e	enum:Simulation::__anon5
Plasticity	simulation.hpp	/^		PopFilter, Plasticity, nModules$/;"	e	enum:Simulation::__anon5
Point	spline.hpp	/^	struct Point { REAL t; T x, v; };$/;"	s	class:Spline
PopFilter	simulation.hpp	/^		PopFilter, Plasticity, nModules$/;"	e	enum:Simulation::__anon5
PopOpt	popfilter.cpp	/^    PopOpt (Cloth &cloth, const vector<Constraint*> &cons):$/;"	f	struct:PopOpt
PopOpt	popfilter.cpp	/^struct PopOpt: public NLOpt {$/;"	s	file:
Proximity	simulation.hpp	/^		Proximity, Physics, StrainLimiting, Collision, Remeshing, Separation,$/;"	e	enum:Simulation::__anon5
Q	vectors.hpp	/^    Mat<n,n> Q;$/;"	m	struct:Eig
Quaternion	transformation.hpp	/^struct Quaternion {$/;"	s
READ_FRAME_BY_FRAME	obstacle.cpp	63;"	d	file:
REAL	real.hpp	6;"	d
REAL	real.hpp	8;"	d
REAL	vectors.hpp	/^template<> inline Vec<3,REAL> operator*<3,REAL>(const REAL &a, const Vec<3,REAL> &v) { __m256d r = _mm256_mul_pd(_mm256_set1_pd(a), (__m256d&)v); return (Vec<3,REAL>&)r; }$/;"	f
REAL	vectors.hpp	/^template<> inline Vec<3,REAL> operator+<3,REAL>(const Vec<3,REAL> &u, const Vec<3,REAL> &v) { __m256d r = _mm256_add_pd((__m256d&)u, (__m256d&)v); return (Vec<3,REAL>&)r; }$/;"	f
REAL	vectors.hpp	/^template<> inline Vec<3,REAL> operator-<3,REAL>(const Vec<3,REAL> &u, const Vec<3,REAL> &v) { __m256d r = _mm256_sub_pd((__m256d&)u, (__m256d&)v); return (Vec<3,REAL>&)r; }$/;"	f
REAL	vectors.hpp	/^template<> inline Vec<3,REAL> operator\/<3,REAL>(const Vec<3,REAL> &u, const REAL &a) { __m256d r = _mm256_div_pd((__m256d&)u, _mm256_set1_pd(a)); return (Vec<3,REAL>&)r; }$/;"	f
REAL	vectors.hpp	/^template<> inline Vec<3,REAL>& operator+=<3,REAL>(Vec<3,REAL> &r, const Vec<3,REAL> &v) { (__m256d&)r = _mm256_add_pd((__m256d&)r, (__m256d&)v); return r; }$/;"	f
REAL	vectors.hpp	/^template<> inline Vec<3,REAL>& operator-=<3,REAL>(Vec<3,REAL> &r, const Vec<3,REAL> &v) { (__m256d&)r = _mm256_sub_pd((__m256d&)r, (__m256d&)v); return r; }$/;"	f
REPORT	util.hpp	146;"	d
REPORT_ARRAY	util.hpp	148;"	d
Range	conf.cpp	/^    Range (REAL &min, REAL &max): min(min), max(max) {}$/;"	f	struct:Range
Range	conf.cpp	/^struct Range {$/;"	s	file:
Remeshing	cloth.hpp	/^	struct Remeshing {$/;"	s	struct:Cloth
Remeshing	simulation.hpp	/^		Proximity, Physics, StrainLimiting, Collision, Remeshing, Separation,$/;"	e	enum:Simulation::__anon5
SEPARATEOBS_HPP	separateobs.hpp	2;"	d
SLOpt	strainlimiting.cpp	/^    SLOpt (vector<Mesh*> &meshes, const vector<Vec2> &strain_limits,$/;"	f	struct:SLOpt
SLOpt	strainlimiting.cpp	/^struct SLOpt: public NLConOpt {$/;"	s	file:
SO	separateobs.cpp	/^namespace SO {$/;"	n	file:
SPARSE_HPP	sparse.hpp	2;"	d
STRAINLIMITING_HPP	strainlimiting.hpp	2;"	d
SVD	vectors.hpp	/^template <int m, int n> struct SVD {$/;"	s
S_plastic	mesh.hpp	/^	Mat2x2 S_plastic; \/\/ plastic strain$/;"	m	struct:Face
Separation	simulation.hpp	/^		Proximity, Physics, StrainLimiting, Collision, Remeshing, Separation,$/;"	e	enum:Simulation::__anon5
SeparationOpt	separateobs.cpp	/^    SeparationOpt (const vector<Ixn> &ixns): ixns(ixns), inv_m(0) {$/;"	f	struct:SO::SeparationOpt
SeparationOpt	separateobs.cpp	/^struct SeparationOpt: public NLConOpt {$/;"	s	namespace:SO	file:
Simulation	simulation.hpp	/^struct Simulation {$/;"	s
SpMat	sparse.hpp	/^    SpMat (): m(0), n(0), rows() {}$/;"	f	struct:SpMat
SpMat	sparse.hpp	/^    explicit SpMat (int m, int n): m(m), n(n), rows(m) {}$/;"	f	struct:SpMat
SpMat	sparse.hpp	/^template <typename T> struct SpMat {$/;"	s
SpVec	sparse.hpp	/^template <typename T> struct SpVec {$/;"	s
Space	geometry.hpp	/^enum Space {PS, WS}; \/\/ plastic space, world space$/;"	g
Spline	spline.hpp	/^class Spline {$/;"	c
StrainLimiting	simulation.hpp	/^		Proximity, Physics, StrainLimiting, Collision, Remeshing, Separation,$/;"	e	enum:Simulation::__anon5
StretchingData	dde.hpp	/^struct StretchingData { Vec4 d[2][5]; };$/;"	s
StretchingSamples	dde.hpp	/^struct StretchingSamples { Vec4 s[40][40][40]; };$/;"	s
T	eigen.cpp	/^typedef Triplet<REAL> T;$/;"	t	file:
TIMING_BEGIN	timer.hpp	103;"	d
TIMING_BEGIN	timer.hpp	112;"	d
TIMING_BEGIN1	timer.hpp	116;"	d
TIMING_END	timer.hpp	106;"	d
TIMING_END	timer.hpp	113;"	d
TIMING_END1	timer.hpp	119;"	d
Timer	timer.cpp	/^Timer::Timer() : last(0), total(0) {$/;"	f	class:Timer
Timer	timer.hpp	/^struct Timer {$/;"	s
Transformation	transformation.cpp	/^Transformation::Transformation(REAL factor) {$/;"	f	class:Transformation
Transformation	transformation.hpp	/^struct Transformation {$/;"	s
U	vectors.hpp	/^    Mat<m,m> U;$/;"	m	struct:SVD
VECTORS_HPP	vectors.hpp	3;"	d
Vec	vectors.hpp	/^    Vec () {for (int i = 0; i < n; i++) c[i] = 0;}$/;"	f	class:Vec
Vec	vectors.hpp	/^    explicit Vec (T x) {for (int i = 0; i < n; i++) c[i] = x;}$/;"	f	class:Vec
Vec	vectors.hpp	/^    explicit Vec (T x, T y) {static_assert(n==2); c[0] = x; c[1] = y;}$/;"	f	class:Vec
Vec	vectors.hpp	/^    explicit Vec (T x, T y, T z) {static_assert(n==3); c[0] = x; c[1] = y; c[2] = z;}$/;"	f	class:Vec
Vec	vectors.hpp	/^    explicit Vec (T x, T y, T z, T w) {static_assert(n==4); c[0] = x; c[1] = y; c[2] = z; c[3] = w;}$/;"	f	class:Vec
Vec	vectors.hpp	/^template <int n, typename T=REAL> class Vec {$/;"	c
Vec2	vectors.hpp	/^typedef Vec<2> Vec2;$/;"	t
Vec3	vectors.hpp	/^typedef Vec<3> Vec3;$/;"	t
Vec4	dde.hpp	/^typedef Vec<4> Vec4;$/;"	t
Vec4	mot_parser.hpp	/^typedef Vec<4> Vec4;$/;"	t
VecmT	vectors.hpp	120;"	d
VecmT	vectors.hpp	186;"	d
VecnT	vectors.hpp	111;"	d
VecnT	vectors.hpp	121;"	d
VecnT	vectors.hpp	187;"	d
VecnT	vectors.hpp	50;"	d
Velocity	conf.cpp	/^struct Velocity {Vec3 v, w; Vec3 o;};$/;"	s	file:
Vert	mesh.hpp	/^	Vert() {}$/;"	f	struct:Vert
Vert	mesh.hpp	/^	explicit Vert(const Vec2 &u, int label = 0) :$/;"	f	struct:Vert
Vert	mesh.hpp	/^	explicit Vert(const Vec3 &x, int label = 0) :$/;"	f	struct:Vert
Vert	mesh.hpp	/^struct Vert {$/;"	s
Vt	vectors.hpp	/^    Mat<n,n> Vt;$/;"	m	struct:SVD
WIN32_LEAN_AND_MEAN	main.cpp	3;"	d	file:
WINPORT_HPP	winport.hpp	3;"	d
WS	geometry.hpp	/^enum Space {PS, WS}; \/\/ plastic space, world space$/;"	e	enum:Space
Weights	morph.hpp	/^	typedef std::vector<REAL> Weights;$/;"	t	struct:Morph
Wind	simulation.hpp	/^struct Wind {$/;"	s
_USE_MATH_DEFINES	winport.hpp	16;"	d
__align	vectors.hpp	17;"	d
__align	vectors.hpp	22;"	d
__getVtx	tmbvh.cpp	/^REAL *__getVtx(int idx)$/;"	f
_active	collision.cpp	/^	bool _active;$/;"	m	struct:g_impactZone	file:
_bound	tmbvh.hpp	/^	contour _bound;$/;"	m	class:bvh_node
_box	tmbvh.hpp	/^	BOX _box;$/;"	m	class:bvh_node
_child	tmbvh.hpp	/^	int _child; \/\/ >=0 leaf with tri_id, <0 left & right$/;"	m	class:bvh_node
_eps_f	optimization.hpp	/^    REAL _eps_x, _eps_f, _eps_g;$/;"	m	struct:OptOptions
_eps_g	optimization.hpp	/^    REAL _eps_x, _eps_f, _eps_g;$/;"	m	struct:OptOptions
_eps_x	optimization.hpp	/^    REAL _eps_x, _eps_f, _eps_g;$/;"	m	struct:OptOptions
_f	collision.cpp	/^	bool _f;$/;"	m	struct:g_impactNode	file:
_flag	tmbvh.hpp	/^	unsigned int _flag; \/\/ vailid or not$/;"	m	class:front_node
_frees	collision.cpp	/^	bool _frees[4];$/;"	m	struct:g_impact	file:
_frees	collision.cpp	/^	bool _frees[4];$/;"	m	struct:tmImpactInfo	file:
_frees	collision.cpp	/^	vector<bool>  _frees;$/;"	m	struct:g_impactZone	file:
_get_subvec	popfilter.cpp	/^inline Vec3 _get_subvec(const REAL*x, int i) {$/;"	f
_ids	gpu.cpp	/^	unsigned int _ids[3];$/;"	m	class:tri3f	file:
_impacts	collision.cpp	/^	vector<g_impact> _impacts;$/;"	m	struct:g_impactZone	file:
_inv_m	collision.cpp	/^	REAL _inv_m;$/;"	m	struct:gNormalOpt	file:
_left	tmbvh.hpp	/^	bvh_node *_left, *_right;$/;"	m	class:front_node
_m	collision.cpp	/^	REAL _m;$/;"	m	struct:g_impactNode	file:
_max	tmbvh.hpp	/^	vec3f _max;$/;"	m	class:aabb
_max_iter	optimization.hpp	/^    int _max_iter;$/;"	m	struct:OptOptions
_min	tmbvh.hpp	/^	vec3f _min;$/;"	m	class:aabb
_n	collision.cpp	/^	Vec3 _n;$/;"	m	struct:g_impact	file:
_n	collision.cpp	/^	Vec3 _n;$/;"	m	struct:tmImpactInfo	file:
_n	collision.cpp	/^	uint _n;$/;"	m	struct:g_impactNode	file:
_nodes	collision.cpp	/^	uint _nodes[4];$/;"	m	struct:g_impact	file:
_nodes	collision.cpp	/^	uint _nodes[4];$/;"	m	struct:tmImpactInfo	file:
_nodes	collision.cpp	/^	vector<uint> _nodes;$/;"	m	struct:g_impactZone	file:
_nodes	tmbvh.hpp	/^	bvh_node *_nodes;$/;"	m	class:bvh
_num	tmbvh.hpp	/^	int _num; \/\/ all face num$/;"	m	class:bvh
_ox	collision.cpp	/^	Vec3 _ox;$/;"	m	struct:g_impactNode	file:
_p	tmbvh.cpp	/^	float _p;$/;"	m	class:aap	file:
_parent	tmbvh.hpp	/^	int _parent;$/;"	m	class:bvh_node
_ptr	tmbvh.hpp	/^	unsigned int _ptr; \/\/ self-coliding parent;$/;"	m	class:front_node
_right	tmbvh.hpp	/^	bvh_node *_left, *_right;$/;"	m	class:front_node
_set_subvec	popfilter.cpp	/^inline void _set_subvec(REAL *x, int i, const Vec3 &xi)$/;"	f
_t	collision.cpp	/^	REAL _t;$/;"	m	struct:g_impact	file:
_t	collision.cpp	/^	REAL _t;$/;"	m	struct:tmImpactInfo	file:
_type	collision.cpp	/^	ImpactType _type;$/;"	m	struct:g_impact	file:
_type	collision.cpp	/^	ImpactType _type;$/;"	m	struct:tmImpactInfo	file:
_w	collision.cpp	/^	REAL _w[4];$/;"	m	struct:g_impact	file:
_w	collision.cpp	/^	REAL _w[4];$/;"	m	struct:tmImpactInfo	file:
_x	collision.cpp	/^	Vec3 _x;$/;"	m	struct:g_impactNode	file:
_x	mesh.hpp	/^	Vec3 *_x, *_x0;$/;"	m	struct:Mesh
_x0	mesh.hpp	/^	Vec3 *_x, *_x0;$/;"	m	struct:Mesh
_xyz	tmbvh.cpp	/^	char _xyz;$/;"	m	class:aap	file:
_zone	collision.cpp	/^	g_impactZone *_zone;$/;"	m	struct:gNormalOpt	file:
a	constraint.hpp	/^	REAL a; \/\/ area$/;"	m	struct:IneqCon
a	mesh.hpp	/^	REAL a, m; \/\/ area, mass$/;"	m	struct:Face
a	mesh.hpp	/^	REAL a, m; \/\/ area, mass$/;"	m	struct:Node
a	mesh.hpp	/^	REAL a, m; \/\/ area, mass$/;"	m	struct:Vert
a0	popfilter.cpp	/^    vector<Vec3> x0, a0;$/;"	m	struct:PopOpt	file:
aabb	tmbvh.hpp	/^	FORCEINLINE aabb() {$/;"	f	class:aabb
aabb	tmbvh.hpp	/^	FORCEINLINE aabb(const vec3f &a, const vec3f &b) {$/;"	f	class:aabb
aabb	tmbvh.hpp	/^	FORCEINLINE aabb(const vec3f &v) {$/;"	f	class:aabb
aabb	tmbvh.hpp	/^class aabb {$/;"	c
aap	tmbvh.cpp	/^	FORCEINLINE aap(const BOX &total) {$/;"	f	class:aap
aap	tmbvh.cpp	/^class aap {$/;"	c	file:
acceleration	mesh.hpp	/^	Vec3 acceleration;$/;"	m	struct:Node
accum	timer.hpp	/^	float		accum;$/;"	m	struct:GPUTimer2
activated	handle.hpp	/^	bool activated;$/;"	m	struct:NodeHandle
activated	obstacle.hpp	/^	bool activated;$/;"	m	struct:Obstacle
active	handle.hpp	/^	bool active(REAL t) { return t >= start_time && t <= end_time; }$/;"	f	struct:Handle
add	auglag.cpp	/^static void add (real_1d_array &x, const vector<double> &y) {$/;"	f	file:
add	mesh.cpp	/^void Mesh::add (Edge *edge) {$/;"	f	class:Mesh
add	mesh.cpp	/^void Mesh::add (Face *face) {$/;"	f	class:Mesh
add	mesh.cpp	/^void Mesh::add (Node *node) {$/;"	f	class:Mesh
add	mesh.cpp	/^void Mesh::add (Vert *vert) {$/;"	f	class:Mesh
add_edges_if_needed	mesh.cpp	/^void add_edges_if_needed (Mesh &mesh, const Face *face) {$/;"	f
add_impacts	collision.cpp	/^void add_impacts(const vector<g_impact> &impacts, vector<g_impactZone*> &zones, bool deform) {$/;"	f
add_position_constraints	handle.cpp	/^void add_position_constraints (const Node *node, const Vec3 &x, REAL stiff,$/;"	f
add_strain_row	strainlimiting.cpp	/^void add_strain_row (const Mat3x3 &sg, const Face *face,$/;"	f
add_submat	popfilter.cpp	/^static void add_submat (SpMat<REAL> &A, int i, int j, const Mat3x3 &Aij) {$/;"	f	file:
add_subvec	auglag.hpp	/^inline void add_subvec (double *x, int i, const Vec3 &xi) {$/;"	f
add_subvec	optimization.hpp	/^inline void add_subvec(double *x, int i, const Vec3 &xi) {$/;"	f
add_subvec	optimization.hpp	/^template <int n> void add_subvec(double *x, int i, const Vec<n> &xi) {$/;"	f
adjacent	separateobs.cpp	/^bool adjacent (const Face *face0, const Face *face1) {$/;"	f	namespace:SO
adje	mesh.hpp	/^	Edge *adje[3]; \/\/ adjacent edges$/;"	m	struct:Face
adje	mesh.hpp	/^	std::vector<Edge*> adje; \/\/ adjacent edges$/;"	m	struct:Node
adjf	mesh.hpp	/^	Face *adjf[2]; \/\/ adjacent faces$/;"	m	struct:Edge
adjf	mesh.hpp	/^	std::vector<Face*> adjf; \/\/ adjacent faces$/;"	m	struct:Vert
advance_step_gpu	gpu.cpp	/^void advance_step_gpu(Simulation &sim)$/;"	f
aligned_free	vectors.hpp	/^inline void aligned_free(void *ptr)    { _aligned_free(ptr); }$/;"	f
aligned_free	vectors.hpp	/^inline void aligned_free(void *ptr)    { free(ptr); }$/;"	f
angle	io.cpp	/^static double angle(const Vec3 &x0, const Vec3 &x1, const Vec3 &x2) {$/;"	f	file:
append	util.hpp	/^inline void append(std::vector<T> &xs, const std::vector<T> &ys) {$/;"	f
append_frame	mot_parser.cpp	/^void append_frame(BodyVector &bodies, size_t body_index, const BodyFrame& bf) {$/;"	f
apply	constraint.hpp	/^	virtual void apply() {}$/;"	f	struct:Constraint
apply	constraint.hpp	/^	void apply() { node->x = x; }$/;"	f	struct:EqCon
apply	sparse.hpp	/^	void apply(const std::vector<T> &x, std::vector <T> &y) const$/;"	f	struct:SpMat
apply	transformation.cpp	/^Vec3 Transformation::apply (const Vec3 &x) const {$/;"	f	class:Transformation
apply_dtrans	transformation.cpp	/^Vec3 apply_dtrans (const DTransformation &dtrans, const Vec3 &x0, Vec3 *vel) {$/;"	f
apply_dtrans_vec	transformation.cpp	/^Vec3 apply_dtrans_vec (const DTransformation &dtrans, const Vec3 &v0) {$/;"	f
apply_inelastic_projection	collision.cpp	/^void apply_inelastic_projection(g_impactZone *zone, REAL dt)$/;"	f
apply_pop_filter	popfilter.cpp	/^void apply_pop_filter (Cloth &cloth, const vector<Constraint*> &cons,$/;"	f
apply_transformation	mesh.cpp	/^void apply_transformation (Mesh& mesh, const Transformation& tr) {$/;"	f
apply_transformation_onto	mesh.cpp	/^void apply_transformation_onto (const Mesh &start_state, Mesh &onto,$/;"	f
apply_transpose	sparse.hpp	/^	void apply_transpose(const std::vector<T> &x, std::vector<T> &y) const$/;"	f	struct:SpMat
apply_vec	transformation.cpp	/^Vec3 Transformation::apply_vec (const Vec3 &v) const {$/;"	f	class:Transformation
apply_velocity	conf.cpp	/^void apply_velocity (Mesh &mesh, const Velocity &vel) {$/;"	f
area_color2	simulation.cpp	/^Vec3 area_color2(const Face *face) {$/;"	f
aspect_min	cloth.hpp	/^		REAL aspect_min; \/\/ aspect ratio control$/;"	m	struct:Cloth::Remeshing
auglag_value_and_grad	auglag.cpp	/^static void auglag_value_and_grad (const real_1d_array &x, double &value,$/;"	f	file:
augmented_lagrangian_method	auglag.cpp	/^void augmented_lagrangian_method (const NLConOpt &problem, OptOptions opt,$/;"	f
axis	gpu.cpp	/^	static vec3f axis(int n) {$/;"	f	class:vec3f
b	main.cpp	/^bool b[256];$/;"	v
b0	separateobs.cpp	/^    Bary b0, b1;$/;"	m	struct:SO::Ixn	file:
b1	separateobs.cpp	/^    Bary b0, b1;$/;"	m	struct:SO::Ixn	file:
backup	handle.hpp	/^	void backup(const vector<Cloth>&ms) {$/;"	f	struct:GlueHandle
backup	handle.hpp	/^	void backup(const vector<Cloth>&ms) {$/;"	f	struct:NodeHandle
backup	handle.hpp	/^	void backup(const vector<Cloth>&ms) {}$/;"	f	struct:AttachHandle
backup	handle.hpp	/^	void backup(const vector<Cloth>&ms) {}$/;"	f	struct:CircleHandle
base_mesh	obstacle.hpp	/^	Mesh base_mesh;$/;"	m	struct:Obstacle
begin_window_coords	main.cpp	/^void begin_window_coords()$/;"	f
bending	cloth.hpp	/^		BendingData bending;$/;"	m	struct:Cloth::Material
bending_stiffness	dde.cpp	/^REAL bending_stiffness (const Edge *edge, int side,$/;"	f
blend_with_previous	obstacle.cpp	/^void Obstacle::blend_with_previous (REAL t, REAL dt, REAL blend) {$/;"	f	class:Obstacle
blockdiag	blockvectors.hpp	/^template <int bn, int m, int n, typename T> Mat<m*bn, n*bn, T> blockdiag(const Mat<m, n, T> &A) {$/;"	f
bodyColliding	gpu.cpp	/^bool bodyColliding(Vec3 &pt0, Vec3 &pt1)$/;"	f
body_vector_to_transforms	mot_parser.cpp	/^vector<vector<Transformation> > body_vector_to_transforms(BodyVector& bodies) {$/;"	f
bodyframe_to_transformation	mot_parser.cpp	/^Transformation bodyframe_to_transformation(const BodyFrame& bodyFrame) {$/;"	f
box	tmbvh.hpp	/^	FORCEINLINE BOX &box() { return _box; }$/;"	f	class:bvh_node
build_cubic_spline	mot_parser.cpp	/^Spline<Transformation> build_cubic_spline($/;"	f
bvh	tmbvh.cpp	/^bvh::bvh(std::vector<Mesh*> &ms, bool cloth)$/;"	f	class:bvh
bvh	tmbvh.hpp	/^class bvh {$/;"	c
bvhC	gpu.cpp	/^bvh *bvhC = NULL;$/;"	v
bvh_node	tmbvh.hpp	/^	bvh_node() {$/;"	f	class:bvh_node
bvh_node	tmbvh.hpp	/^class bvh_node {$/;"	c
c	handle.hpp	/^	REAL c; \/\/ circumference$/;"	m	struct:CircleHandle
c	vectors.hpp	/^    VecmT c[n];$/;"	m	class:Mat
c	vectors.hpp	/^  __align(32) T c[n%4? 4*(1+n\/4): n];$/;"	m	class:Vec
center	tmbvh.hpp	/^	FORCEINLINE vec3f center() const { return (_min+_max)*REAL(0.5); }$/;"	f	class:aabb
check	mesh.cpp	/^template <typename T1, typename T2> void check (const T1 *p1, const T2 *p2,$/;"	f
checkGLError	main.cpp	/^void checkGLError()$/;"	f
checkModel	simulation.cpp	/^void checkModel()$/;"	f
check_step	gpu.cpp	/^void check_step(Simulation &sim) {$/;"	f
check_that_contents_are_sane	mesh.cpp	/^bool check_that_contents_are_sane (const Mesh &mesh) {$/;"	f
check_that_pointers_are_sane	mesh.cpp	/^bool check_that_pointers_are_sane (const Mesh &mesh) {$/;"	f
cid	handle.hpp	/^	int id1, id2, cid, oid;$/;"	m	struct:AttachHandle
clamp	util.hpp	/^template <typename T> T clamp(const T &x, const T &a, const T &b) {$/;"	f
clamp_violation	auglag.cpp	/^inline double clamp_violation (double x, int sign) {$/;"	f
clean_up_quaternions	transformation.cpp	/^void clean_up_quaternions (Motion &motion) {$/;"	f
cloth	popfilter.cpp	/^    Cloth &cloth;$/;"	m	struct:PopOpt	file:
cloth_meshes	simulation.hpp	/^	std::vector<Mesh*> cloth_meshes, obstacle_meshes;$/;"	m	struct:Simulation
cloths	simulation.hpp	/^	std::vector<Cloth> cloths;$/;"	m	struct:Simulation
col	vectors.hpp	/^    VecmT &col (int j) {return c[j];}$/;"	f	class:Mat
col	vectors.hpp	/^    const VecmT &col (int j) const {return c[j];}$/;"	f	class:Mat
collide	tmbvh.hpp	/^	void collide(bvh *other, front_list &f) {$/;"	f	class:bvh
collide	tmbvh.hpp	/^	void collide(bvh_node *other, front_list &f, int level, int ptr)$/;"	f	class:bvh_node
collision_response_gpu	collision.cpp	/^void collision_response_gpu(REAL dt, REAL mu, REAL mu_obs, REAL mrt, REAL mcs)$/;"	f
collision_step_gpu	gpu.cpp	/^void collision_step_gpu(Simulation &sim)$/;"	f
collision_stiffness	magic.hpp	/^	REAL handle_stiffness, collision_stiffness;$/;"	m	struct:Magic
combine_tensors	magic.hpp	/^	bool combine_tensors;$/;"	m	struct:Magic
complain	conf.cpp	/^void complain (const Json::Value &json, const string &expected) {$/;"	f
compressobjfile	gpu.cpp	/^bool compressobjfile(const char *path, const char *opath)$/;"	f
compute_masses	cloth.hpp	/^inline void compute_masses(Cloth &cloth)$/;"	f
compute_ms_data	mesh.cpp	/^void compute_ms_data (Edge* edge) {$/;"	f
compute_ms_data	mesh.cpp	/^void compute_ms_data (Face* face) {$/;"	f
compute_ms_data	mesh.cpp	/^void compute_ms_data (Mesh &mesh) {$/;"	f
compute_ms_data	mesh.cpp	/^void compute_ms_data (Node* node) {$/;"	f
compute_ms_data	mesh.cpp	/^void compute_ms_data (Vert* vert) {$/;"	f
compute_ws_data	mesh.cpp	/^void compute_ws_data (Edge *edge) {$/;"	f
compute_ws_data	mesh.cpp	/^void compute_ws_data (Face* face) {$/;"	f
compute_ws_data	mesh.cpp	/^void compute_ws_data (Mesh &mesh) {$/;"	f
compute_ws_data	mesh.cpp	/^void compute_ws_data (Node* node) {$/;"	f
con_grad	collision.cpp	/^gNormalOpt::con_grad(const double *x, int j, double factor, double *grad) const$/;"	f	class:gNormalOpt
con_grad	separateobs.cpp	/^void SeparationOpt::con_grad (const double *x, int j, double factor,$/;"	f	class:SO::SeparationOpt
con_grad	strainlimiting.cpp	/^void SLOpt::con_grad (const double *x, int j, double factor,$/;"	f	class:SLOpt
conflict	collision.cpp	/^bool conflict(const g_impact&i0, const g_impact&i1) {$/;"	f
connect	mesh.cpp	/^void connect (Vert *vert, Node *node) {$/;"	f
conold	strainlimiting.cpp	/^    vector<double> conold;$/;"	m	struct:SLOpt	file:
cons	popfilter.cpp	/^    const vector<Constraint*> &cons;$/;"	m	struct:PopOpt	file:
cons	strainlimiting.cpp	/^    const vector<Constraint*> &cons;$/;"	m	struct:SLOpt	file:
constraint	collision.cpp	/^gNormalOpt::constraint(const double *x, int j, int &sign) const$/;"	f	class:gNormalOpt
constraint	separateobs.cpp	/^REAL SeparationOpt::constraint (const double *x, int j, int &sign) const {$/;"	f	class:SO::SeparationOpt
constraint	strainlimiting.cpp	/^REAL SLOpt::constraint (const double *x, int j, int &sign) const {$/;"	f	class:SLOpt
construct	tmbvh.cpp	/^bvh_node::construct(unsigned int *lst, unsigned int num)$/;"	f	class:bvh_node
construct	tmbvh.cpp	/^bvh_node::construct(unsigned int id)$/;"	f	class:bvh_node
construct	tmbvh.cpp	/^void bvh::construct(std::vector<Mesh*> &ms, bool cloth)$/;"	f	class:bvh
construct	tmbvh.cpp	/^void bvh::construct(std::vector<Mesh*> &ms, const char *fname, bool cloth)$/;"	f	class:bvh
covertex	tmbvh.cpp	/^bool covertex(int id1, int id2)$/;"	f
cross	gpu.cpp	/^	FORCEINLINE const vec3f cross(const vec3f &vec) const$/;"	f	class:vec3f
cross	vectors.hpp	/^template <typename T> Vec<3,T> cross (const Vec<3,T> &u, const Vec<3,T> &v) {Vec<3,T> w; w[0] = u[1]*v[2] - u[2]*v[1]; w[1] = u[2]*v[0] - u[0]*v[2]; w[2] = u[0]*v[1] - u[1]*v[0]; return w;}$/;"	f
curr_state_mesh	obstacle.hpp	/^	Mesh curr_state_mesh;$/;"	m	struct:Obstacle
currentNodes	collision.cpp	/^vector<g_impactNode> *currentNodes = NULL;$/;"	v
d	dde.hpp	/^struct BendingData { REAL d[3][5]; };$/;"	m	struct:BendingData
d	dde.hpp	/^struct StretchingData { Vec4 d[2][5]; };$/;"	m	struct:StretchingData
damage	mesh.hpp	/^	REAL damage; \/\/ accumulated norm of S_plastic\/S_yield$/;"	m	struct:Face
damage	mesh.hpp	/^	REAL theta_ideal, damage; \/\/ rest dihedral angle, damage parameter$/;"	m	struct:Edge
damping	cloth.hpp	/^		REAL damping; \/\/ stiffness-proportional damping coefficient$/;"	m	struct:Cloth::Material
dataPath	main.cpp	/^char *dataPath;$/;"	v
debug	strainlimiting.cpp	/^void debug(const vector<string> &args)$/;"	f
debug_cpu	strainlimiting.cpp	/^void debug_cpu (char *ofile)$/;"	f
debug_gpu	strainlimiting.cpp	/^void debug_gpu(char *ofile)$/;"	f
debug_save_mesh	util.cpp	/^void debug_save_mesh(const Mesh &mesh, const string &name, int n) {$/;"	f
debug_save_meshes	util.cpp	/^void debug_save_meshes(const vector<Mesh*> &meshvec, const string &name,$/;"	f
deep_copy	mesh.cpp	/^Mesh deep_copy (const Mesh &mesh0) {$/;"	f
deform_obstacles	collision.cpp	/^static bool deform_obstacles;$/;"	v	file:
delete_constraints	equilibration.cpp	/^void delete_constraints(const vector<Constraint*> &cons) {$/;"	f
delete_mesh	mesh.cpp	/^void delete_mesh (Mesh &mesh) {$/;"	f
density	cloth.hpp	/^		REAL density; \/\/ area density$/;"	m	struct:Cloth::Material
density	simulation.hpp	/^	REAL density;$/;"	m	struct:Wind
depth	tmbvh.hpp	/^	FORCEINLINE REAL depth()  const { return _max[2] - _min[2]; }$/;"	f	class:aabb
derivative	mesh.hpp	/^Mat<n, 2> derivative(Vec<n> w0, Vec<n> w1, Vec<n> w2, const Face *face) {$/;"	f
derivative	mesh.hpp	/^inline Mat2x3 derivative(const Face *face) {$/;"	f
derivative	mesh.hpp	/^inline Vec2 derivative(REAL a0, REAL a1, REAL a2, const Face *face) {$/;"	f
det	vectors.hpp	/^template <typename T> T det (const Mat<2,2,T> &A) {return A(0,0)*A(1,1) - A(0,1)*A(1,0);}$/;"	f
det	vectors.hpp	/^template <typename T> T det (const Mat<3,3,T> &A) {return stp(A.col(0), A.col(1), A.col(2));}$/;"	f
diag	vectors.hpp	/^template <int n, typename T> MatnnT diag (const VecnT &u) {MatnnT A = MatnnT(0); for (int j = 0; j < n; j++) A(j,j) = u[j]; return A;}$/;"	f
diag	vectors.hpp	/^template <int n, typename T> VecnT diag (const MatnnT &A) {VecnT u; for (int j = 0; j < n; j++) u[j] = A(j,j); return u;}$/;"	f
dihedral_angle	geometry.cpp	/^template <Space s> REAL dihedral_angle(const Edge *edge) {$/;"	f
directions	handle.cpp	/^static Vec3 directions[3] = {Vec3(1,0,0), Vec3(0,1,0), Vec3(0,0,1)};$/;"	v	file:
display	main.cpp	/^void display()$/;"	f
dot	gpu.cpp	/^	FORCEINLINE double dot(const vec3f &vec) const {$/;"	f	class:vec3f
dot	vectors.hpp	/^tpl T dot (const VecnT &u, const VecnT &v) {T d = 0; for (int i = 0; i < n; i++) d += u[i]*v[i]; return d;}$/;"	f
drag	simulation.hpp	/^	REAL drag;$/;"	m	struct:Wind
draw	main.cpp	/^void draw()$/;"	f
drawGround	main.cpp	/^void drawGround()$/;"	f
drawModel	simulation.cpp	/^void drawModel(bool tt, bool cone, bool mdl, bool, int level)$/;"	f
draw_handles	simulation.cpp	/^void draw_handles()$/;"	f
draw_mesh	simulation.cpp	/^void draw_mesh(const Mesh &mesh, bool set_color = false) {$/;"	f
draw_meshes	simulation.cpp	/^void draw_meshes(bool set_color = false) {$/;"	f
draw_seam_or_boundary_edges	simulation.cpp	/^void draw_seam_or_boundary_edges() {$/;"	f
dx0	handle.hpp	/^	Vec3 xc, dx0, dx1;$/;"	m	struct:CircleHandle
dx1	handle.hpp	/^	Vec3 xc, dx0, dx1;$/;"	m	struct:CircleHandle
dynamicModel	simulation.cpp	/^bool dynamicModel(char *, bool, bool)$/;"	f
edge_flip_threshold	magic.hpp	/^	REAL edge_flip_threshold;$/;"	m	struct:Magic
edge_opp_vert	mesh.cpp	/^Vert *edge_opp_vert (const Edge *edge, int side) {$/;"	f
edge_vert	mesh.cpp	/^Vert *edge_vert (const Edge *edge, int side, int i) {$/;"	f
edges	mesh.hpp	/^	std::vector<Edge*> edges;$/;"	m	struct:Mesh
ee_clear_distance	separateobs.cpp	/^REAL ee_clear_distance (const Face *face0, const Face *face1, const Vec3 &d,$/;"	f	namespace:SO
eigen_decomposition	vectors.cpp	/^template <int n> Eig<n> eigen_decomposition (const Mat<n,n> &A) {$/;"	f
eigen_decomposition	vectors.cpp	/^template<> Eig<2> eigen_decomposition<2>(const Mat2x2 &A) {$/;"	f
eigen_linear_solve	eigen.cpp	/^std::vector<REAL> eigen_linear_solve(const SpMat<REAL> &A,$/;"	f
empty	tmbvh.hpp	/^	FORCEINLINE bool empty() const {$/;"	f	class:aabb
enabled	simulation.hpp	/^	bool enabled[nModules];$/;"	m	struct:Simulation
endCapture	main.cpp	/^void endCapture()$/;"	f
end_frame	simulation.hpp	/^	REAL end_time, end_frame;$/;"	m	struct:Simulation
end_time	handle.hpp	/^	REAL start_time, end_time, fade_time;$/;"	m	struct:Handle
end_time	obstacle.hpp	/^	REAL start_time, end_time;$/;"	m	struct:Obstacle
end_time	simulation.hpp	/^	REAL end_time, end_frame;$/;"	m	struct:Simulation
end_window_coords	main.cpp	/^void end_window_coords()$/;"	f
energy	constraint.cpp	/^REAL EqCon::energy (REAL value) {return stiff*sq(value)\/2.;}$/;"	f	class:EqCon
energy	constraint.cpp	/^REAL GlueCon::energy (REAL value) {return stiff*sq(value)\/2.;}$/;"	f	class:GlueCon
energy	constraint.cpp	/^REAL IneqCon::energy (REAL value) {$/;"	f	class:IneqCon
energy_grad	constraint.cpp	/^REAL EqCon::energy_grad (REAL value) {return stiff*value;}$/;"	f	class:EqCon
energy_grad	constraint.cpp	/^REAL GlueCon::energy_grad (REAL value) {return stiff*value;}$/;"	f	class:GlueCon
energy_grad	constraint.cpp	/^REAL IneqCon::energy_grad (REAL value) {$/;"	f	class:IneqCon
energy_hess	constraint.cpp	/^REAL EqCon::energy_hess (REAL value) {return stiff;}$/;"	f	class:EqCon
energy_hess	constraint.cpp	/^REAL GlueCon::energy_hess (REAL value) {return stiff;}$/;"	f	class:GlueCon
energy_hess	constraint.cpp	/^REAL IneqCon::energy_hess (REAL value) {$/;"	f	class:IneqCon
enlarge	tmbvh.hpp	/^	FORCEINLINE void enlarge(REAL thickness) {$/;"	f	class:aabb
ensure_existing_directory	io.cpp	/^void ensure_existing_directory(const std::string &path) {$/;"	f
entries	sparse.hpp	/^    std::vector<T> entries;$/;"	m	struct:SpVec
eps_f	optimization.hpp	/^    OptOptions &eps_f (REAL e) {_eps_f = e; return *this;}$/;"	f	struct:OptOptions
eps_f	optimization.hpp	/^    REAL eps_f () {return _eps_f;}$/;"	f	struct:OptOptions
eps_g	optimization.hpp	/^    OptOptions &eps_g (REAL e) {_eps_g = e; return *this;}$/;"	f	struct:OptOptions
eps_g	optimization.hpp	/^    REAL eps_g () {return _eps_g;}$/;"	f	struct:OptOptions
eps_x	optimization.hpp	/^    OptOptions &eps_x (REAL e) {_eps_x = e; return *this;}$/;"	f	struct:OptOptions
eps_x	optimization.hpp	/^    REAL eps_x () {return _eps_x;}$/;"	f	struct:OptOptions
equal_abs	gpu.cpp	/^	FORCEINLINE bool equal_abs(const vec3f &other) const {$/;"	f	class:vec3f
equilibration_step	equilibration.cpp	/^void equilibration_step(Simulation &sim) {$/;"	f
error	mot_parser.hpp	/^	std::string error;$/;"	m	class:mot_parser_exception
evaluate_stretching_sample	dde.cpp	/^Vec4 evaluate_stretching_sample (const Mat2x2 &_G, const StretchingData &data) {$/;"	f
evaluate_stretching_samples	dde.cpp	/^void evaluate_stretching_samples (StretchingSamples &samples, const StretchingData &data) {$/;"	f
exclude	util.hpp	/^template <typename T> inline void exclude(const T &x, std::vector<T> &xs) {$/;"	f
f	mesh.hpp	/^	Vec3 f; \/\/friction $/;"	m	struct:Node
f	popfilter.cpp	/^    mutable vector<Vec3> f;$/;"	m	struct:PopOpt	file:
f0	separateobs.cpp	/^    Face *f0, *f1;$/;"	m	struct:SO::Ixn	file:
f1	separateobs.cpp	/^    Face *f0, *f1;$/;"	m	struct:SO::Ixn	file:
face_normals	separateobs.cpp	/^vector<Vec3> face_normals (const vector<Mesh*> &meshes) {$/;"	f	namespace:SO
face_plane_intersection	separateobs.cpp	/^bool face_plane_intersection (const Face *face, const Face *plane,$/;"	f	namespace:SO
faces	mesh.hpp	/^	std::vector<Face*> faces;$/;"	m	struct:Mesh
fade_time	handle.hpp	/^	REAL start_time, end_time, fade_time;$/;"	m	struct:Handle
farthest_points	separateobs.cpp	/^bool farthest_points (const Face *face0, const Face *face1, const Vec3 &d,$/;"	f	namespace:SO
fill_in_velocity	spline.hpp	/^template <typename T> void fill_in_velocity(Spline<T> &s, int i) {$/;"	f
finalize	collision.cpp	/^void gNormalOpt::finalize(const double *x) const {$/;"	f	class:gNormalOpt
finalize	popfilter.cpp	/^void PopOpt::finalize (const REAL *x) const {$/;"	f	class:PopOpt
finalize	separateobs.cpp	/^void SeparationOpt::finalize (const double *x) const {$/;"	f	class:SO::SeparationOpt
finalize	strainlimiting.cpp	/^void SLOpt::finalize (const double *x) const {$/;"	f	class:SLOpt
find	spline.cpp	/^static int find (const Spline<T> &s, REAL t) {$/;"	f	file:
find	util.hpp	/^template <typename T> inline int find(const T &x, const T *xs, int n = 3) {$/;"	f
find	util.hpp	/^template <typename T> inline int find(const T &x, const std::vector<T> &xs) {$/;"	f
find	util.hpp	/^template <typename T> inline int find(const T *x, T* const *xs, int n = 3) {$/;"	f
find_face_intersection	separateobs.cpp	/^void find_face_intersection (const Face *face0, const Face *face1) {$/;"	f	namespace:SO
find_in_meshes	collision.cpp	/^pair<bool, int> find_in_meshes(const Node *node) {$/;"	f
find_index	sparse.hpp	/^inline size_t find_index (int i, const std::vector<int> &indices) {$/;"	f
find_intersections	separateobs.cpp	/^vector<Ixn> find_intersections (const vector<AccelStruct*> &accs,$/;"	f	namespace:SO
find_mesh	collision.cpp	/^int find_mesh(const Prim *p, const vector<Mesh*> &meshes) {$/;"	f
find_node	mesh.hpp	/^	Node *find_node(int id) {$/;"	f	struct:Mesh
find_or_create_zone	collision.cpp	/^g_impactZone *find_or_create_zone(uint node, bool free, vector<g_impactZone*> &zones) {$/;"	f
finite	winport.hpp	/^template <class T> inline bool   finite(const T& number) { return boost::math::isfinite(number); }$/;"	f
fixed_high_res_mesh	magic.hpp	/^	bool fixed_high_res_mesh;$/;"	m	struct:Magic
flip_image	io.cpp	/^void flip_image(int w, int h, unsigned char *pixels) {$/;"	f
fpsBuffer	main.cpp	/^static char fpsBuffer[512];$/;"	v	file:
frame	simulation.hpp	/^	int frame, step;$/;"	m	struct:Simulation
frame_steps	simulation.hpp	/^	int frame_steps;$/;"	m	struct:Simulation
frame_time	simulation.hpp	/^	REAL frame_time, step_time;$/;"	m	struct:Simulation
free	constraint.hpp	/^	bool free[4];$/;"	m	struct:IneqCon
friction	constraint.cpp	/^MeshGrad EqCon::friction (REAL dt, MeshHess &jac) {return MeshGrad();}$/;"	f	class:EqCon
friction	constraint.cpp	/^MeshGrad GlueCon::friction (REAL dt, MeshHess &jac) {return MeshGrad();}$/;"	f	class:GlueCon
friction	constraint.cpp	/^MeshGrad IneqCon::friction (REAL dt, MeshHess &jac) {$/;"	f	class:IneqCon
friction	simulation.hpp	/^	REAL friction, obs_friction;$/;"	m	struct:Simulation
friction_color	simulation.cpp	/^Vec3 friction_color(const Face *face) {$/;"	f
from_axisangle	transformation.cpp	/^Quaternion Quaternion::from_axisangle(const Vec3 &axis, REAL angle) {$/;"	f	class:Quaternion
front_list	tmbvh.hpp	/^class front_list : public vector<front_node> {$/;"	c
front_node	tmbvh.hpp	/^	FORCEINLINE front_node(bvh_node *l, bvh_node *r, unsigned int ptr)$/;"	f	class:front_node
front_node	tmbvh.hpp	/^class front_node {$/;"	c
gNormalOpt	collision.cpp	/^	gNormalOpt() : _zone(NULL), _inv_m(0) { nvar = ncon = 0; }$/;"	f	struct:gNormalOpt
gNormalOpt	collision.cpp	/^	gNormalOpt(g_impactZone *zone) : _zone(zone), _inv_m(0) {$/;"	f	struct:gNormalOpt
gNormalOpt	collision.cpp	/^struct gNormalOpt : public NLConOpt {$/;"	s	file:
g_impact	collision.cpp	/^	g_impact()$/;"	f	struct:g_impact
g_impact	collision.cpp	/^	g_impact(ImpactType type, uint n0, uint n1, uint n2, uint n3, bool f0, bool f1, bool f2, bool f3)$/;"	f	struct:g_impact
g_impact	collision.cpp	/^struct g_impact {$/;"	s	file:
g_impactNode	collision.cpp	/^	g_impactNode() {$/;"	f	struct:g_impactNode
g_impactNode	collision.cpp	/^	g_impactNode(uint n, bool f) {$/;"	f	struct:g_impactNode
g_impactNode	collision.cpp	/^struct g_impactNode {$/;"	s	file:
g_impactZone	collision.cpp	/^struct g_impactZone {$/;"	s	file:
g_timing_start	main.cpp	/^double g_timing_start = 0;$/;"	v
get	mesh.cpp	/^template <> const vector<Edge*> &get (const Mesh &mesh) {return mesh.edges;}$/;"	f
get	mesh.cpp	/^template <> const vector<Face*> &get (const Mesh &mesh) {return mesh.faces;}$/;"	f
get	mesh.cpp	/^template <> const vector<Node*> &get (const Mesh &mesh) {return mesh.nodes;}$/;"	f
get	mesh.cpp	/^template <> const vector<Vert*> &get (const Mesh &mesh) {return mesh.verts;}$/;"	f
get	simulation.cpp	/^template <typename Prim> Prim *get(int i, const vector<Mesh*> &meshes) {$/;"	f
getLevel	tmbvh.hpp	/^	FORCEINLINE void getLevel(int current, int &max_level) {$/;"	f	class:bvh_node
getLevelIdx	tmbvh.hpp	/^	FORCEINLINE void getLevelIdx(int current, unsigned int *idx) {$/;"	f	class:bvh_node
getMax	tmbvh.hpp	/^	vec3f getMax() { return _max; }$/;"	f	class:aabb
getMin	tmbvh.hpp	/^	vec3f getMin() { return _min; }$/;"	f	class:aabb
getNodeID	gpu.cpp	/^int getNodeID(Simulation &sim, Node *n)$/;"	f
getUnit	gpu.cpp	/^	FORCEINLINE vec3f getUnit() const {$/;"	f	class:vec3f
get_body_frame	mot_parser.cpp	/^BodyFrame& get_body_frame(BodyVector &bodies, size_t body_index, size_t frame) {$/;"	f
get_body_frames	mot_parser.cpp	/^BodyFrameVector& get_body_frames(BodyVector &bodies, size_t body_index) {$/;"	f
get_bound_idx	tmbvh.hpp	/^	int get_bound_idx(int r, int i){$/;"	f	class:bvh_node
get_bound_length	tmbvh.hpp	/^	int get_bound_length()$/;"	f	class:bvh_node
get_constraints	equilibration.cpp	/^vector<Constraint*> get_constraints(Simulation &sim, bool include_proximity) {$/;"	f
get_constraints	handle.cpp	/^vector<Constraint*> AttachHandle::get_constraints(REAL t) {$/;"	f	class:AttachHandle
get_constraints	handle.cpp	/^vector<Constraint*> CircleHandle::get_constraints (REAL t) {$/;"	f	class:CircleHandle
get_constraints	handle.cpp	/^vector<Constraint*> GlueHandle::get_constraints (REAL t) {$/;"	f	class:GlueHandle
get_constraints	handle.cpp	/^vector<Constraint*> NodeHandle::get_constraints (REAL t) {$/;"	f	class:NodeHandle
get_dtrans	transformation.cpp	/^DTransformation get_dtrans (const Motion &motion, REAL t) {$/;"	f
get_edge	mesh.cpp	/^Edge *get_edge (const Node *n0, const Node *n1) {$/;"	f
get_index	simulation.cpp	/^template <typename Prim> int get_index(const Prim *p,$/;"	f
get_mass	collision.cpp	/^REAL get_mass(const Node *node) { return is_free(node) ? node->m : obs_mass; }$/;"	f
get_mass	collision.cpp	/^inline REAL get_mass(uint n, bool f)$/;"	f
get_mesh	obstacle.cpp	/^Mesh& Obstacle::get_mesh() {$/;"	f	class:Obstacle
get_mesh	obstacle.cpp	/^Mesh& Obstacle::get_mesh(REAL time) {$/;"	f	class:Obstacle
get_mesh	obstacle.cpp	/^const Mesh& Obstacle::get_mesh() const {$/;"	f	class:Obstacle
get_nodes	handle.hpp	/^	std::vector<Node*> get_nodes() { return std::vector<Node*>(); }$/;"	f	struct:AttachHandle
get_nodes	handle.hpp	/^	std::vector<Node*> get_nodes() { return std::vector<Node*>(); }$/;"	f	struct:CircleHandle
get_nodes	handle.hpp	/^	std::vector<Node*> get_nodes() { return std::vector<Node*>(1, node); }$/;"	f	struct:NodeHandle
get_nodes	handle.hpp	/^	std::vector<Node*> get_nodes() {$/;"	f	struct:GlueHandle
get_strain_limits	strainlimiting.cpp	/^vector<Vec2> get_strain_limits (const vector<Cloth> &cloths) {$/;"	f
get_submat	popfilter.cpp	/^static Mat3x3 get_submat (SpMat<REAL> &A, int i, int j) {$/;"	f	file:
get_subvec	auglag.hpp	/^inline Vec3 get_subvec (const double *x, int i) {$/;"	f
get_subvec	optimization.hpp	/^inline Vec3 get_subvec (const double *x, int i) {$/;"	f
get_subvec	optimization.hpp	/^template <int n> Vec<n> get_subvec(const double *x, int i) {$/;"	f
get_trans	transformation.cpp	/^Transformation get_trans (const Motion &motion, REAL t) {$/;"	f
get_valid_line	io.cpp	/^void get_valid_line(istream &in, string &line) {$/;"	f
get_x	collision.cpp	/^inline Vec3 get_x(uint n, bool f)$/;"	f
get_x0	collision.cpp	/^inline Vec3 get_x0(uint n, bool f)$/;"	f
get_xold	collision.cpp	/^inline Vec3 get_xold(uint n, bool f)$/;"	f
glSim	simulation.cpp	/^Simulation *glSim;$/;"	v
gradient	constraint.cpp	/^MeshGrad EqCon::gradient () {MeshGrad grad; grad[node] = n; return grad;}$/;"	f	class:EqCon
gradient	constraint.cpp	/^MeshGrad GlueCon::gradient () {$/;"	f	class:GlueCon
gradient	constraint.cpp	/^MeshGrad IneqCon::gradient () {$/;"	f	class:IneqCon
gradient	popfilter.cpp	/^void PopOpt::gradient (const REAL *x, REAL *g) const {$/;"	f	class:PopOpt
gravity	simulation.hpp	/^	Vec3 gravity;$/;"	m	struct:Simulation
handle_stiffness	magic.hpp	/^	REAL handle_stiffness, collision_stiffness;$/;"	m	struct:Magic
handles	simulation.hpp	/^	std::vector<Handle*> handles;$/;"	m	struct:Simulation
height	tmbvh.hpp	/^	FORCEINLINE REAL height() const { return _max[1] - _min[1]; }$/;"	f	class:aabb
hessian	optimization.hpp	/^    virtual bool hessian (const REAL *x, SpMat<REAL> &H) const {$/;"	f	struct:NLOpt
hessian	popfilter.cpp	/^bool PopOpt::hessian (const REAL *x, SpMat<REAL> &H) const {$/;"	f	class:PopOpt
id	gpu.cpp	/^	FORCEINLINE unsigned int id(int i) { return _ids[i]; }$/;"	f	class:tri3f
id0	gpu.cpp	/^	FORCEINLINE unsigned int id0() { return _ids[0]; }$/;"	f	class:tri3f
id1	gpu.cpp	/^	FORCEINLINE unsigned int id1() { return _ids[1]; }$/;"	f	class:tri3f
id1	handle.hpp	/^	int id1, id2, cid, oid;$/;"	m	struct:AttachHandle
id2	gpu.cpp	/^	FORCEINLINE unsigned int id2() { return _ids[2]; }$/;"	f	class:tri3f
id2	handle.hpp	/^	int id1, id2, cid, oid;$/;"	m	struct:AttachHandle
identityT	transformation.cpp	/^Transformation identityT () {$/;"	f
idle	main.cpp	/^void idle()$/;"	f
include	util.hpp	/^template <typename T> inline void include(const T &x, std::vector<T> &xs) {$/;"	f
independent_impacts	collision.cpp	/^vector<g_impact> independent_impacts(const vector<g_impact> &impacts) {$/;"	f
index	handle.hpp	/^	int index;$/;"	m	struct:NodeHandle
index	mesh.hpp	/^	int index; \/\/ position in mesh.edges$/;"	m	struct:Edge
index	mesh.hpp	/^	int index; \/\/ position in mesh.faces$/;"	m	struct:Face
index	mesh.hpp	/^	int index; \/\/ position in mesh.nodes$/;"	m	struct:Node
index	mesh.hpp	/^	int index; \/\/ position in mesh.verts$/;"	m	struct:Vert
indices	handle.hpp	/^	int indices[2];$/;"	m	struct:GlueHandle
indices	sparse.hpp	/^    std::vector<int> indices;$/;"	m	struct:SpVec
infinity	util.cpp	/^const REAL infinity = numeric_limits<REAL>::infinity();$/;"	v
infinityNorm	gpu.cpp	/^	FORCEINLINE double infinityNorm() const$/;"	f	class:vec3f
init	handle.hpp	/^	bool init;$/;"	m	struct:AttachHandle
init	tmbvh.hpp	/^	FORCEINLINE void init() {$/;"	f	class:aabb
initMenu	main.cpp	/^void initMenu()$/;"	f
initModel	main.cpp	/^void initModel(int argc, char **argv, char *path, int st)$/;"	f
initOpengl	main.cpp	/^void initOpengl()$/;"	f
initSetting	main.cpp	/^void initSetting()$/;"	f
init_cuda	init.cpp	/^void init_cuda(int argc, char **argv)$/;"	f
init_handles	gpu.cpp	/^void init_handles(Simulation &sim)$/;"	f
init_physics	simulation.cpp	/^void init_physics(const string &json_file, string outprefix, bool is_reloading)$/;"	f
init_resume	simulation.cpp	/^void init_resume(char *path, int st)$/;"	f
initialize	collision.cpp	/^void gNormalOpt::initialize(double *x) const {$/;"	f	class:gNormalOpt
initialize	popfilter.cpp	/^void PopOpt::initialize (REAL *x) const {$/;"	f	class:PopOpt
initialize	separateobs.cpp	/^void SeparationOpt::initialize (double *x) const {$/;"	f	class:SO::SeparationOpt
initialize	strainlimiting.cpp	/^void SLOpt::initialize (double *x) const {$/;"	f	class:SLOpt
input2	util.cpp	/^void input2(const char *fname, REAL *data, int len)$/;"	f
insert_index	sparse.hpp	/^template <typename T> void insert_index (int i, int j,$/;"	f
inside	tmbvh.cpp	/^	FORCEINLINE bool inside(const vec3f &mid) const {$/;"	f	class:aap
inside	tmbvh.hpp	/^	FORCEINLINE bool inside(const vec3f &p) const$/;"	f	class:aabb
interp	util.hpp	/^template <typename T> T interp(const T &a, const T &b, const T &w) {$/;"	f
intersection_midpoint	separateobs.cpp	/^bool intersection_midpoint (const Face *face0, const Face *face1,$/;"	f	namespace:SO
inv	vectors.hpp	/^    MatmnT inv () const {return inverse(*this);}$/;"	f	class:Mat
invDm	mesh.hpp	/^	Mat2x2 Dm, invDm; \/\/ finite element matrix$/;"	m	struct:Face
inv_m	separateobs.cpp	/^    REAL inv_m;$/;"	m	struct:SO::SeparationOpt	file:
inv_m	strainlimiting.cpp	/^    REAL inv_m;$/;"	m	struct:SLOpt	file:
inverse	transformation.cpp	/^Quaternion inverse(const Quaternion &q) {$/;"	f
inverse	transformation.cpp	/^Transformation inverse(const Transformation &tr) {$/;"	f
inverse	vectors.hpp	/^template <typename T> Mat<2,2,T> inverse (const Mat<2,2,T> &A) {return Mat<2,2,T>(Vec<2,T>(A(1,1), -A(1,0)), Vec<2,T>(-A(0,1), A(0,0)))\/det(A);}$/;"	f
inverse	vectors.hpp	/^template <typename T> Mat<3,3,T> inverse (const Mat<3,3,T> &A) {return Mat<3,3,T>(cross(A.col(1),A.col(2)), cross(A.col(2),A.col(0)), cross(A.col(0),A.col(1))).t()\/det(A);}$/;"	f
isLeaf	tmbvh.hpp	/^	FORCEINLINE int isLeaf() { return _child >= 0; }$/;"	f	class:bvh_node
isUnit	gpu.cpp	/^	FORCEINLINE bool isUnit() const {$/;"	f	class:vec3f
is_all_whitespace	mot_parser.cpp	/^bool is_all_whitespace(const string& empty) {$/;"	f
is_free	collision.cpp	/^template <typename Primitive> bool is_free(const Primitive *p) {$/;"	f
is_in	collision.cpp	/^bool is_in(uint id, const uint ids[], const bool frees[])$/;"	f
is_in	collision.cpp	/^bool is_in(uint node, bool free, g_impactZone *z)$/;"	f
is_in	util.hpp	/^template <typename T> inline bool is_in(const T &x, const T *xs, int n = 3) {$/;"	f
is_in	util.hpp	/^template <typename T> inline bool is_in(const T &x, const std::vector<T> &xs) {$/;"	f
is_in	util.hpp	/^template <typename T> inline bool is_in(const T *x, T* const *xs, int n = 3) {$/;"	f
is_in_gpu	simulation.hpp	/^	bool is_in_gpu;$/;"	m	struct:Simulation
is_seam_or_boundary	util.cpp	/^bool is_seam_or_boundary(const Edge *e) {$/;"	f
is_seam_or_boundary	util.cpp	/^bool is_seam_or_boundary(const Face *f) {$/;"	f
is_seam_or_boundary	util.cpp	/^bool is_seam_or_boundary(const Node *n) {$/;"	f
is_seam_or_boundary	util.cpp	/^bool is_seam_or_boundary(const Vert *v) {$/;"	f
isfinite	winport.hpp	/^template <class T> inline bool isfinite(const T& number) { return boost::math::isfinite(number); }$/;"	f
ixns	separateobs.cpp	/^    const vector<Ixn> &ixns;$/;"	m	struct:SO::SeparationOpt	file:
ixns	separateobs.cpp	/^static vector<Ixn> *ixns = NULL;$/;"	m	namespace:SO	file:
key	main.cpp	/^void key(unsigned char k, int x, int y)$/;"	f
key1	main.cpp	/^void key1()$/;"	f
key2	main.cpp	/^void key2()$/;"	f
key3	main.cpp	/^void key3()$/;"	f
key_s	simulation.cpp	/^void key_s()$/;"	f
l	mesh.hpp	/^	REAL l; \/\/ length$/;"	m	struct:Edge
l	vectors.hpp	/^    Vec<n> l;$/;"	m	struct:Eig
label	handle.hpp	/^	int label;$/;"	m	struct:CircleHandle
label	mesh.hpp	/^	int label;$/;"	m	struct:Edge
label	mesh.hpp	/^	int label;$/;"	m	struct:Face
label	mesh.hpp	/^	int label;$/;"	m	struct:Node
label	mesh.hpp	/^	int label;$/;"	m	struct:Vert
lambda	auglag.cpp	/^static vector<double> lambda;$/;"	v	file:
last	timer.hpp	/^	double last, total, then;$/;"	m	struct:Timer
left	tmbvh.hpp	/^	FORCEINLINE bvh_node *left() { return this - _child; }$/;"	f	class:bvh_node
length	gpu.cpp	/^	FORCEINLINE double length() const {$/;"	f	class:vec3f
level	main.cpp	/^static int level = 1;$/;"	v	file:
lightpos	main.cpp	/^float lightpos[4] = {13, 10.2, 3.2, 0};$/;"	v
load_animation	gpu.cpp	/^void load_animation()$/;"	f
load_json	conf.cpp	/^void load_json (const string &configFilename, Simulation &sim) {$/;"	f
load_material_data	conf.cpp	/^void load_material_data (Cloth::Material &material, const string &filename) {$/;"	f
load_mesh	obstacle.cpp	/^Obstacle::load_mesh(REAL t, REAL dt, REAL blend)$/;"	f	class:Obstacle
load_mesh	obstacle.cpp	/^Obstacle::load_mesh(Vec3 *pts)$/;"	f	class:Obstacle
load_mot	mot_parser.cpp	/^std::vector<Motion> load_mot (const std::string &filename, double fps) {$/;"	f
load_obj	io.cpp	/^void load_obj(Mesh &mesh, const string &filename)$/;"	f
load_obj_vertices	io.cpp	/^int load_obj_vertices(const string &filename, vector<Vec3> &verts)$/;"	f
load_objs	io.cpp	/^void load_objs(vector<Mesh*> &meshes, const string &prefix) {$/;"	f
log2	winport.hpp	/^template <class T> inline T log2(const T& number) { return log(number)\/log(T(2)); }$/;"	f
log_stiffness	morph.hpp	/^	Spline<REAL> log_stiffness;$/;"	m	struct:Morph
m	mesh.hpp	/^	REAL a, m; \/\/ area, mass$/;"	m	struct:Face
m	mesh.hpp	/^	REAL a, m; \/\/ area, mass$/;"	m	struct:Node
m	mesh.hpp	/^	REAL a, m; \/\/ area, mass$/;"	m	struct:Vert
m	sparse.hpp	/^    int m, n;$/;"	m	struct:SpMat
magic	magic.cpp	/^Magic magic;$/;"	v
main	main.cpp	/^int main(int argc, char **argv)$/;"	f
main_menu	main.cpp	/^void main_menu(int i)$/;"	f
major_axis	separateobs.cpp	/^int major_axis (const Vec3 &v) {$/;"	f	namespace:SO
malloc_align	vectors.hpp	/^inline void* malloc_align(size_t size, size_t alignment = 32) { return _aligned_malloc(size, alignment); }$/;"	f
malloc_align	vectors.hpp	/^inline void* malloc_align(size_t size, size_t alignment = 32) {$/;"	f
mark_nodes_to_preserve	mesh.cpp	/^void mark_nodes_to_preserve (Mesh &mesh) {$/;"	f
mat_to_vec	blockvectors.hpp	/^Vec<m*n, T> mat_to_vec(const Mat<m, n, T> &A) {$/;"	f
materials	cloth.hpp	/^	std::vector<Material *> materials;$/;"	m	struct:Cloth
max	conf.cpp	/^    REAL &min, &max;$/;"	m	struct:Range	file:
max	util.hpp	/^template <typename T> T max(const T &a, const T &b, const T &c) {$/;"	f
max	util.hpp	/^template <typename T> T max(const T &a, const T &b, const T &c, const T &d) {$/;"	f
max	winport.hpp	21;"	d
max_iter	collision.cpp	/^static const int max_iter = 100;$/;"	v	file:
max_iter	optimization.hpp	/^    OptOptions &max_iter (int n) {_max_iter = n; return *this;}$/;"	f	struct:OptOptions
max_iter	optimization.hpp	/^    int max_iter () {return _max_iter;}$/;"	f	struct:OptOptions
max_iter	separateobs.cpp	/^static const int max_iter = 100;$/;"	m	namespace:SO	file:
mergeVtxs	gpu.cpp	/^void mergeVtxs(const char *ipath, const char *opath)$/;"	f
merge_zones	collision.cpp	/^void merge_zones(g_impactZone* zone0, g_impactZone *zone1)$/;"	f
merge_zones	collision.cpp	/^void merge_zones(g_impactZone* zone0, g_impactZone *zone1,$/;"	f
mesh	cloth.hpp	/^	Mesh mesh;$/;"	m	struct:Cloth
mesh	handle.hpp	/^	Mesh *mesh;$/;"	m	struct:CircleHandle
mesh	morph.hpp	/^	Mesh *mesh;$/;"	m	struct:Morph
mesh	popfilter.cpp	/^    Mesh &mesh;$/;"	m	struct:PopOpt	file:
mesh	strainlimiting.cpp	/^static Mesh mesh;$/;"	v	file:
mesh_id	tmbvh.cpp	/^void mesh_id(int id, vector<Mesh *> &m, int &mid, int &fid)$/;"	f
meshes	collision.cpp	/^const vector<Mesh*> *meshes, *obs_meshes;$/;"	v
meshes	simulation.cpp	/^static vector<Mesh*> &meshes = sim.cloth_meshes;$/;"	v	file:
meshes	strainlimiting.cpp	/^    vector<Mesh*> meshes;$/;"	m	struct:SLOpt	file:
mid	handle.hpp	/^	int mid;$/;"	m	struct:NodeHandle
mid	handle.hpp	/^	int mid[2];$/;"	m	struct:GlueHandle
min	conf.cpp	/^    REAL &min, &max;$/;"	m	struct:Range	file:
min	util.hpp	/^template <typename T> T min(const T &a, const T &b, const T &c) {$/;"	f
min	util.hpp	/^template <typename T> T min(const T &a, const T &b, const T &c, const T &d) {$/;"	f
min	winport.hpp	20;"	d
morphs	simulation.hpp	/^	std::vector<Morph> morphs;$/;"	m	struct:Simulation
mot_parser_exception	mot_parser.hpp	/^	mot_parser_exception(const std::string& error) : error(error) {}$/;"	f	class:mot_parser_exception
mot_parser_exception	mot_parser.hpp	/^class mot_parser_exception {$/;"	c
mot_to_spline	mot_parser.cpp	/^vector<Spline<Transformation> > mot_to_spline(string motion_file, const Transformation& tr,$/;"	f
mot_to_transforms	mot_parser.cpp	/^vector<vector<Transformation> > mot_to_transforms(string motion_file) {$/;"	f
motion	handle.hpp	/^	const Motion *motion;$/;"	m	struct:CircleHandle
motion	handle.hpp	/^	const Motion *motion;$/;"	m	struct:NodeHandle
motion	main.cpp	/^void motion(int x, int y)$/;"	f
motions	simulation.hpp	/^	std::vector<Motion> motions;$/;"	m	struct:Simulation
mouse	main.cpp	/^void mouse(int button, int state, int x, int y)$/;"	f
moveMesh	gpu.cpp	/^void moveMesh()$/;"	f
mu	auglag.cpp	/^static double mu;$/;"	v	file:
mu	constraint.hpp	/^	REAL mu; \/\/ friction$/;"	m	struct:IneqCon
mu	popfilter.cpp	/^static REAL mu;$/;"	v	file:
multiplier_update	auglag.cpp	/^static void multiplier_update (const real_1d_array &x) {$/;"	f	file:
n	constraint.hpp	/^	Vec3 n;$/;"	m	struct:GlueCon
n	constraint.hpp	/^	Vec3 n;$/;"	m	struct:IneqCon
n	constraint.hpp	/^	Vec3 x, n;$/;"	m	struct:EqCon
n	mesh.hpp	/^	Node *n[2]; \/\/ nodes$/;"	m	struct:Edge
n	mesh.hpp	/^	Vec3 n; \/\/ local normal, approximate$/;"	m	struct:Node
n	mesh.hpp	/^	Vec3 n; \/\/ local normal, exact$/;"	m	struct:Face
n	separateobs.cpp	/^    Vec3 n;$/;"	m	struct:SO::Ixn	file:
n	sparse.hpp	/^    int m, n;$/;"	m	struct:SpMat
nModules	simulation.hpp	/^		PopFilter, Plasticity, nModules$/;"	e	enum:Simulation::__anon5
name	util.cpp	/^template <typename T> string name(const T *p) {$/;"	f
ncon	auglag.hpp	/^    int nvar, ncon;$/;"	m	struct:NLOpt
ncon	optimization.hpp	/^    int nvar, ncon;$/;"	m	struct:NLConOpt
negate	gpu.cpp	/^	FORCEINLINE void negate() {$/;"	f	class:vec3f
nf	strainlimiting.cpp	/^    int nn, nf;$/;"	m	struct:SLOpt	file:
nn	strainlimiting.cpp	/^    int nn, nf;$/;"	m	struct:SLOpt	file:
node	constraint.hpp	/^	Node *node;$/;"	m	struct:EqCon
node	handle.hpp	/^	Node *node;$/;"	m	struct:NodeHandle
node	mesh.hpp	/^	Node *node; \/\/ world space$/;"	m	struct:Vert
node_color	simulation.cpp	/^void node_color(const Node *node) {$/;"	f
node_positions	simulation.cpp	/^vector<Vec3> node_positions(const vector<Mesh*> &meshes) {$/;"	f
nodes	constraint.hpp	/^	Node *nodes[2];$/;"	m	struct:GlueCon
nodes	constraint.hpp	/^	Node *nodes[4];$/;"	m	struct:IneqCon
nodes	handle.hpp	/^	Node* nodes[2];$/;"	m	struct:GlueHandle
nodes	mesh.hpp	/^	std::vector<Node*> nodes;$/;"	m	struct:Mesh
nodes	separateobs.cpp	/^    vector<Node*> nodes;$/;"	m	struct:SO::SeparationOpt	file:
nold	separateobs.cpp	/^static vector<Vec3> nold;$/;"	m	namespace:SO	file:
nor	geometry.cpp	/^template <Space s> Vec3 nor(const Face *face) {$/;"	f
norm	vectors.hpp	/^tpl T norm (const VecnT &u) {return sqrt(norm2(u));}$/;"	f
norm2	transformation.cpp	/^REAL norm2(const Quaternion &q) {$/;"	f
norm2	vectors.hpp	/^tpl T norm2 (const VecnT &u) {return dot(u,u);}$/;"	f
norm2_F	vectors.hpp	/^tpl T norm2_F (const MatmnT &A) {T a = 0; for (int j = 0; j < n; j++) a += norm2(A.col(j)); return a;}$/;"	f
norm_F	vectors.hpp	/^tpl T norm_F (const MatmnT &A) {return sqrt(norm2_F(A));}$/;"	f
normal	simulation.cpp	/^void normal(const Vec3 &n) {$/;"	f
normalize	gpu.cpp	/^	FORCEINLINE void normalize()$/;"	f	class:vec3f
normalize	handle.cpp	/^Transformation normalize (const Transformation &T) {$/;"	f
normalize	transformation.cpp	/^Quaternion normalize (const Quaternion &q) {$/;"	f
normalize	vectors.hpp	/^tpl VecnT normalize (const VecnT &u) {T m = norm(u); return m==0 ? VecnT(0) : u\/m;}$/;"	f
not_all_null	mesh.cpp	/^template <typename T1, typename T2> void not_all_null$/;"	f
not_any_null	mesh.cpp	/^template <typename T1, typename T2> void not_any_null$/;"	f
not_null	mesh.cpp	/^template <typename T1, typename T2> void not_null (const T1 *p1, const T2 *p2) {$/;"	f
nsamples	dde.cpp	/^static const int nsamples = 30;$/;"	v	file:
nthreads	collision.cpp	/^static int nthreads = 0;$/;"	v	file:
nthreads	separateobs.cpp	/^static int nthreads = 0;$/;"	m	namespace:SO	file:
num_bodies	mot_parser.cpp	/^size_t num_bodies(BodyVector &bodies) {$/;"	f
num_frames	mot_parser.cpp	/^size_t num_frames(BodyVector &bodies) {$/;"	f
nvar	auglag.hpp	/^    int nvar, ncon;$/;"	m	struct:NLOpt
nvar	optimization.hpp	/^    int nvar, ncon;$/;"	m	struct:NLConOpt
nvar	optimization.hpp	/^    int nvar;$/;"	m	struct:NLOpt
o	conf.cpp	/^struct Velocity {Vec3 v, w; Vec3 o;};$/;"	m	struct:Velocity	file:
obj_grad	collision.cpp	/^void gNormalOpt::obj_grad(const double *x, double *grad) const {$/;"	f	class:gNormalOpt
obj_grad	separateobs.cpp	/^void SeparationOpt::obj_grad (const double *x, double *grad) const {$/;"	f	class:SO::SeparationOpt
obj_grad	strainlimiting.cpp	/^void SLOpt::obj_grad (const double *x, double *grad) const {$/;"	f	class:SLOpt
objective	collision.cpp	/^REAL gNormalOpt::objective(const double *x) const {$/;"	f	class:gNormalOpt
objective	popfilter.cpp	/^REAL PopOpt::objective (const REAL *x) const {$/;"	f	class:PopOpt
objective	separateobs.cpp	/^REAL SeparationOpt::objective (const double *x) const {$/;"	f	class:SO::SeparationOpt
objective	strainlimiting.cpp	/^REAL SLOpt::objective (const double *x) const {$/;"	f	class:SLOpt
obs_friction	simulation.hpp	/^	REAL friction, obs_friction;$/;"	m	struct:Simulation
obs_mass	collision.cpp	/^static REAL obs_mass;$/;"	v	file:
obs_meshes	collision.cpp	/^const vector<Mesh*> *meshes, *obs_meshes;$/;"	v
obstacle_meshes	simulation.hpp	/^	std::vector<Mesh*> cloth_meshes, obstacle_meshes;$/;"	m	struct:Simulation
obstacles	simulation.hpp	/^	std::vector<Obstacle> obstacles;$/;"	m	struct:Simulation
offset	handle.hpp	/^	Vec3 offset;$/;"	m	struct:AttachHandle
oid	handle.hpp	/^	int id1, id2, cid, oid;$/;"	m	struct:AttachHandle
operator !=	vectors.hpp	/^tpl bool operator!= (const VecnT &u, const VecnT &v) {return !(u==v);}$/;"	f
operator ()	sparse.hpp	/^    T &operator() (int i, int j) {\/\/ inserts entry as side-effect$/;"	f	struct:SpMat
operator ()	sparse.hpp	/^    T operator() (int i, int j) const {$/;"	f	struct:SpMat
operator ()	vectors.hpp	/^    T &operator() (int i, int j) {return c[j][i];}$/;"	f	class:Mat
operator ()	vectors.hpp	/^    const T &operator() (int i, int j) const {return c[j][i];}$/;"	f	class:Mat
operator ()	vectors.hpp	/^template <> struct static_assertion_failure<true> {void operator() () {}};$/;"	f	struct:static_assertion_failure
operator *	gpu.cpp	/^	FORCEINLINE vec3f operator *(double t) const$/;"	f	class:vec3f
operator *	spline.cpp	/^vector<REAL> operator* (const vector<REAL> &x, REAL a) {$/;"	f
operator *	transformation.cpp	/^Quaternion Quaternion::operator*(REAL s) const {$/;"	f	class:Quaternion
operator *	transformation.cpp	/^Quaternion Quaternion::operator*(const Quaternion& other) const {$/;"	f	class:Quaternion
operator *	transformation.cpp	/^Transformation Transformation::operator*(REAL s) const {$/;"	f	class:Transformation
operator *	transformation.cpp	/^Transformation Transformation::operator*(const Transformation& other) const {$/;"	f	class:Transformation
operator *	vectors.hpp	/^inline Vec<3,REAL>  operator*(const Vec<3,REAL> &u, const Vec<3,REAL> &v) { __m256d r = _mm256_mul_pd((__m256d&)u, (__m256d&)v); return (Vec<3,REAL>&)r; }$/;"	f
operator *	vectors.hpp	/^template <int m, int n, int o, typename T> Mat<m,o,T> operator* (const Mat<m,n,T> &A, const Mat<n,o,T> &B) {Mat<m,o,T> C; for (int k = 0; k < o; k++) C.col(k) = A*B.col(k); return C;}$/;"	f
operator *	vectors.hpp	/^template <int m, int n, int o, typename T> Mat<m,o,T> operator* (const Mat<m,n,T> &A, const MatTransposed<o,n,T> &B) $/;"	f
operator *	vectors.hpp	/^template <int m, int n, int o, typename T> Mat<m,o,T> operator* (const MatTransposed<n,m,T> &A, const Mat<n,o,T> &B) $/;"	f
operator *	vectors.hpp	/^template <int m, int n, typename T> Vec<n, T> operator* (const MatTransposed<m,n,T> &A, const Vec<m, T> &u) $/;"	f
operator *	vectors.hpp	/^tpl MatmnT operator* (const MatmnT &A, const T &a) {return a*A;}$/;"	f
operator *	vectors.hpp	/^tpl MatmnT operator* (const T &a, const MatmnT &A) {MatmnT B; for (int j = 0; j < n; j++) B.col(j) = a*A.col(j); return B;}$/;"	f
operator *	vectors.hpp	/^tpl VecmT operator* (const MatmnT &A, const VecnT &u) {VecmT v = VecmT(0); for (int j = 0; j < n; j++) v += A.col(j)*u[j]; return v;}$/;"	f
operator *	vectors.hpp	/^tpl VecnT operator* (const T &a, const VecnT &u) {VecnT v; for (int i = 0; i < n; i++) v[i] = a*u[i]; return v;}$/;"	f
operator *	vectors.hpp	/^tpl VecnT operator* (const VecnT &u, const T &a) {return a*u;}$/;"	f
operator *<	vectors.hpp	/^template<> inline Vec<3,REAL> operator*<3,REAL>(const REAL &a, const Vec<3,REAL> &v) { __m256d r = _mm256_mul_pd(_mm256_set1_pd(a), (__m256d&)v); return (Vec<3,REAL>&)r; }$/;"	v
operator *=	gpu.cpp	/^	FORCEINLINE vec3f &operator *= (double t) {$/;"	f	class:vec3f
operator *=	vectors.hpp	/^inline Vec<3,REAL>& operator*=(Vec<3,REAL> &r, const Vec<3,REAL> &v)      { (__m256d&)r = _mm256_mul_pd((__m256d&)r, (__m256d&)v); return r; }$/;"	f
operator *=	vectors.hpp	/^tpl MatmnT &operator*= (MatmnT &A, const T &a) {return A = A*a;}$/;"	f
operator *=	vectors.hpp	/^tpl MatmnT *operator*= (const MatmnT &A, const MatnnT &B) {return A = A*B;}$/;"	f
operator *=	vectors.hpp	/^tpl VecnT &operator*= (VecnT &u, const T &a) {return u = u*a;}$/;"	f
operator +	gpu.cpp	/^	FORCEINLINE vec3f operator+ (const vec3f &v) const$/;"	f	class:vec3f
operator +	spline.cpp	/^vector<REAL> operator+ (const vector<REAL> &x, const vector<REAL> &y) {$/;"	f
operator +	tmbvh.hpp	/^	FORCEINLINE aabb operator + ( const aabb &v) const$/;"	f	class:aabb
operator +	transformation.cpp	/^Quaternion Quaternion::operator+(const Quaternion& other) const {$/;"	f	class:Quaternion
operator +	transformation.cpp	/^Transformation Transformation::operator+(const Transformation& other) const {$/;"	f	class:Transformation
operator +	vectors.hpp	/^tpl MatmnT operator+ (const MatmnT &A) {return A;}$/;"	f
operator +	vectors.hpp	/^tpl MatmnT operator+ (const MatmnT &A, const MatmnT &B) {MatmnT C; for (int j = 0; j < n; j++) C.col(j) = A.col(j) + B.col(j); return C;}$/;"	f
operator +	vectors.hpp	/^tpl VecnT operator+ (const VecnT &u) {return u;}$/;"	f
operator +	vectors.hpp	/^tpl VecnT operator+ (const VecnT &u, const VecnT &v) {VecnT w; for (int i = 0; i < n; i++) w[i] = u[i] + v[i]; return w;}$/;"	f
operator +<	vectors.hpp	/^template<> inline Vec<3,REAL> operator+<3,REAL>(const Vec<3,REAL> &u, const Vec<3,REAL> &v) { __m256d r = _mm256_add_pd((__m256d&)u, (__m256d&)v); return (Vec<3,REAL>&)r; }$/;"	v
operator +=	gpu.cpp	/^	FORCEINLINE vec3f &operator += (const vec3f &v) {$/;"	f	class:vec3f
operator +=	tmbvh.hpp	/^	FORCEINLINE aabb &operator += (const aabb &b)$/;"	f	class:aabb
operator +=	tmbvh.hpp	/^	FORCEINLINE aabb &operator += (const vec3f &p)$/;"	f	class:aabb
operator +=	vectors.hpp	/^tpl MatmnT &operator+= (MatmnT &A, const MatmnT &B) {return A = A + B;}$/;"	f
operator +=	vectors.hpp	/^tpl VecnT &operator+= (VecnT &u, const VecnT &v) {return u = u + v;}$/;"	f
operator +=<	vectors.hpp	/^template<> inline Vec<3,REAL>& operator+=<3,REAL>(Vec<3,REAL> &r, const Vec<3,REAL> &v) { (__m256d&)r = _mm256_add_pd((__m256d&)r, (__m256d&)v); return r; }$/;"	v
operator -	gpu.cpp	/^	FORCEINLINE vec3f operator - () const {$/;"	f	class:vec3f
operator -	gpu.cpp	/^	FORCEINLINE vec3f operator- (const vec3f &v) const$/;"	f	class:vec3f
operator -	spline.cpp	/^vector<REAL> operator- (const vector<REAL> &x, const vector<REAL> &y) {$/;"	f
operator -	transformation.cpp	/^Quaternion Quaternion::operator-() const {$/;"	f	class:Quaternion
operator -	transformation.cpp	/^Quaternion Quaternion::operator-(const Quaternion& other) const {$/;"	f	class:Quaternion
operator -	transformation.cpp	/^Transformation Transformation::operator-(const Transformation& other) const {$/;"	f	class:Transformation
operator -	vectors.hpp	/^tpl MatmnT operator- (const MatmnT &A) {MatmnT B; for (int j = 0; j < n; j++) B.col(j) = -A.col(j); return B;}$/;"	f
operator -	vectors.hpp	/^tpl MatmnT operator- (const MatmnT &A, const MatmnT &B) {return A + (-B);}$/;"	f
operator -	vectors.hpp	/^tpl VecnT operator- (const VecnT &u) {VecnT v; for (int i = 0; i < n; i++) v[i] = -u[i]; return v;}$/;"	f
operator -	vectors.hpp	/^tpl VecnT operator- (const VecnT &u, const VecnT &v) {return u + (-v);}$/;"	f
operator -<	vectors.hpp	/^template<> inline Vec<3,REAL> operator-<3,REAL>(const Vec<3,REAL> &u, const Vec<3,REAL> &v) { __m256d r = _mm256_sub_pd((__m256d&)u, (__m256d&)v); return (Vec<3,REAL>&)r; }$/;"	v
operator -=	gpu.cpp	/^	FORCEINLINE vec3f &operator -= (const vec3f &v) {$/;"	f	class:vec3f
operator -=	vectors.hpp	/^tpl MatmnT &operator-= (MatmnT &A, const MatmnT &B) {return A = A - B;}$/;"	f
operator -=	vectors.hpp	/^tpl VecnT &operator-= (VecnT &u, const VecnT &v) {return u = u - v;}$/;"	f
operator -=<	vectors.hpp	/^template<> inline Vec<3,REAL>& operator-=<3,REAL>(Vec<3,REAL> &r, const Vec<3,REAL> &v) { (__m256d&)r = _mm256_sub_pd((__m256d&)r, (__m256d&)v); return r; }$/;"	v
operator /	gpu.cpp	/^	FORCEINLINE vec3f operator \/(double t) const$/;"	f	class:vec3f
operator /	spline.cpp	/^vector<REAL> operator\/ (const vector<REAL> &x, REAL a) {return x*(1\/a);}$/;"	f
operator /	transformation.cpp	/^Quaternion Quaternion::operator\/(REAL s) const {$/;"	f	class:Quaternion
operator /	transformation.cpp	/^Transformation Transformation::operator\/(REAL s) const {$/;"	f	class:Transformation
operator /	vectors.hpp	/^inline Vec<3,REAL>  operator\/(const Vec<3,REAL> &u, const Vec<3,REAL> &v) { __m256d r = _mm256_div_pd((__m256d&)u, (__m256d&)v); return (Vec<3,REAL>&)r; }$/;"	f
operator /	vectors.hpp	/^tpl MatmnT operator\/ (const MatmnT &A, const T &a) {return A*(1\/a);}$/;"	f
operator /	vectors.hpp	/^tpl VecnT operator\/ (const VecnT &u, const T &a) {return u*(1\/a);}$/;"	f
operator /<	vectors.hpp	/^template<> inline Vec<3,REAL> operator\/<3,REAL>(const Vec<3,REAL> &u, const REAL &a) { __m256d r = _mm256_div_pd((__m256d&)u, _mm256_set1_pd(a)); return (Vec<3,REAL>&)r; }$/;"	v
operator /=	gpu.cpp	/^	FORCEINLINE vec3f &operator \/= (double t) {$/;"	f	class:vec3f
operator /=	vectors.hpp	/^inline Vec<3,REAL>& operator\/=(Vec<3,REAL> &r, const Vec<3,REAL> &v)      { (__m256d&)r = _mm256_div_pd((__m256d&)r, (__m256d&)v); return r; }$/;"	f
operator /=	vectors.hpp	/^tpl MatmnT &operator\/= (MatmnT &A, const T &a) {return A = A\/a;}$/;"	f
operator /=	vectors.hpp	/^tpl VecnT &operator\/= (VecnT &u, const T &a) {return u = u\/a;}$/;"	f
operator <	collision.cpp	/^bool operator < (const g_impact &imp0, const g_impact &imp1) {$/;"	f
operator <	collision.cpp	/^bool operator < (const g_impactNode &n0, const g_impactNode &n1) {$/;"	f
operator <<	separateobs.cpp	/^ostream &operator<< (ostream &out, const Ixn &ixn) {out << ixn.f0 << "@" << ixn.b0 << " " << ixn.f1 << "@" << ixn.b1 << " " << ixn.n; return out;}$/;"	f	namespace:SO
operator <<	sparse.hpp	/^std::ostream &operator<< (std::ostream &out, const SpMat<T> &A) {$/;"	f
operator <<	sparse.hpp	/^std::ostream &operator<< (std::ostream &out, const SpVec<T> &v) {$/;"	f
operator <<	transformation.hpp	/^inline std::ostream &operator<< (std::ostream &out, const Quaternion &q) { out << "(" << q.s << ", " << q.v << ")"; return out; }$/;"	f
operator <<	transformation.hpp	/^inline std::ostream &operator<< (std::ostream &out, const Transformation &t) { out << "(translation: " << t.translation << ", rotation: " << t.rotation << ", scale: " << t.scale << ")"; return out; }$/;"	f
operator <<	util.cpp	/^ostream &operator<< (ostream &out, const Edge *edge) {$/;"	f
operator <<	util.cpp	/^ostream &operator<< (ostream &out, const Face *face) {$/;"	f
operator <<	util.cpp	/^ostream &operator<< (ostream &out, const Node *node) {$/;"	f
operator <<	util.cpp	/^ostream &operator<< (ostream &out, const Vert *vert) {$/;"	f
operator <<	util.hpp	/^std::ostream &operator<< (std::ostream &out, const std::vector<T> &v) {$/;"	f
operator <<	vectors.hpp	/^tpl std::ostream &operator<< (std::ostream &out, const MatmnT &A) {MatnmT At = transpose(A); out << "(" << std::endl; for (int i = 0; i < m; i++) out << "    " << At.col(i) << (i+1==m?"":",") << std::endl; out << ")"; return out;}$/;"	f
operator <<	vectors.hpp	/^tpl std::ostream &operator<< (std::ostream &out, const VecnT &u) {out << "("; for (int i = 0; i < n; i++) out << (i==0?"":", ") << u[i]; out << ")"; return out;}$/;"	f
operator ==	collision.cpp	/^bool operator == (const g_impactNode &n0, const g_impactNode &n1) {$/;"	f
operator ==	gpu.cpp	/^	FORCEINLINE bool operator == (const tri3f &a) {$/;"	f	class:tri3f
operator ==	gpu.cpp	/^	FORCEINLINE bool operator == (const vec3f &other) const {$/;"	f	class:vec3f
operator ==	vectors.hpp	/^tpl bool operator== (const VecnT &u, const VecnT &v) {for(int i=0; i<n; ++i) if(u[i] != v[i]) return false; return true;}$/;"	f
operator []	gpu.cpp	/^	FORCEINLINE double &operator [] (int i) { return v[i]; }$/;"	f	class:vec3f
operator []	gpu.cpp	/^	FORCEINLINE double operator [] (int i) const { return v[i]; }$/;"	f	class:vec3f
operator []	sparse.hpp	/^    T &operator[] (int i) {\/\/ inserts entry as side-effect$/;"	f	struct:SpVec
operator []	sparse.hpp	/^    T operator[] (int i) const {$/;"	f	struct:SpVec
operator []	vectors.hpp	/^    T &operator[] (int i) {return c[i];}$/;"	f	class:Vec
operator []	vectors.hpp	/^    const T &operator[] (int i) const {return c[i];}$/;"	f	class:Vec
operator delete	vectors.hpp	/^inline void  operator delete(void *ptr)   { aligned_free(ptr); }$/;"	f
operator delete[]	vectors.hpp	/^inline void  operator delete[](void *ptr) { aligned_free(ptr); }$/;"	f
operator new	vectors.hpp	/^inline void* operator new(size_t sz)      { return malloc_align(sz); }$/;"	f
operator new[]	vectors.hpp	/^inline void* operator new[](size_t sz)    { return malloc_align(sz); }$/;"	f
orient	mot_parser.hpp	/^	Vec4 orient;$/;"	m	struct:BodyFrame
outer	vectors.hpp	/^tpl MatmnT outer (const VecmT &u, const VecnT &v) {MatmnT A; for (int j = 0; j < n; j++) A.col(j) = u*v[j]; return A;}$/;"	f
outprefix	simulation.cpp	/^string outprefix;$/;"	v
output	util.cpp	/^void output(char *fname, double *data, int len)$/;"	f
output	util.cpp	/^void output(char *fname, float *data, int len)$/;"	f
output	util.cpp	/^void output(char *fname, int *data, int len)$/;"	f
output1	util.cpp	/^void output1(const char *fname, REAL *data, int len)$/;"	f
output12	util.cpp	/^void output12(char *fname, REAL *data, int len)$/;"	f
output12x12	util.cpp	/^void output12x12(char *fname, REAL *data, int len)$/;"	f
output2	util.cpp	/^void output2(const char *fname, REAL *data, int len)$/;"	f
output3x12	util.cpp	/^void output3x12(REAL *data, int st, FILE *fp)$/;"	f
output3x9	util.cpp	/^void output3x9(REAL *data, int st, FILE *fp)$/;"	f
output9	util.cpp	/^void output9(char *fname, REAL *data, int len, bool txt)$/;"	f
output9x9	util.cpp	/^void output9x9(char *fname, REAL *data, int len, bool txt)$/;"	f
output_gpu	strainlimiting.cpp	/^void output_gpu(int i)$/;"	f
overlaps	tmbvh.hpp	/^	FORCEINLINE bool overlaps(const aabb &b, aabb &ret) const$/;"	f	class:aabb
overlaps	tmbvh.hpp	/^	FORCEINLINE bool overlaps(const aabb& b) const$/;"	f	class:aabb
parentID	tmbvh.hpp	/^	FORCEINLINE int parentID() { return _parent; }$/;"	f	class:bvh_node
parse	conf.cpp	/^template <int n> void parse (Vec<n> &v, const Json::Value &json) {$/;"	f
parse	conf.cpp	/^template <typename T> void parse (T &x, const Json::Value &json, const T &x0) {$/;"	f
parse	conf.cpp	/^template <typename T> void parse (vector<T> &v, const Json::Value &json) {$/;"	f
parse	conf.cpp	/^void parse (BendingData &data, const Json::Value &json) {$/;"	f
parse	conf.cpp	/^void parse (Box &box, const Json::Value &json, const Box &box0) {$/;"	f
parse	conf.cpp	/^void parse (Cloth &cloth, const Json::Value &json) {$/;"	f
parse	conf.cpp	/^void parse (Cloth::Material *&mat, const Json::Value &json) {$/;"	f
parse	conf.cpp	/^void parse (Cloth::Remeshing &remeshing, const Json::Value &json) {$/;"	f
parse	conf.cpp	/^void parse (Magic &magic, const Json::Value &json) {$/;"	f
parse	conf.cpp	/^void parse (Motion &motion, const Json::Value &json) {$/;"	f
parse	conf.cpp	/^void parse (Motion::Point &mp, const Json::Value &json) {$/;"	f
parse	conf.cpp	/^void parse (REAL &x, const Json::Value &json) {$/;"	f
parse	conf.cpp	/^void parse (Range range, const Json::Value &json, Vec2 range0) {$/;"	f
parse	conf.cpp	/^void parse (StretchingSamples &samples, const Json::Value &json) {$/;"	f
parse	conf.cpp	/^void parse (Transformation& transform, const Json::Value &json) {$/;"	f
parse	conf.cpp	/^void parse (Velocity &velocity, const Json::Value &json) {$/;"	f
parse	conf.cpp	/^void parse (Wind &wind, const Json::Value &json) {$/;"	f
parse	conf.cpp	/^void parse (bool &b, const Json::Value &json) {$/;"	f
parse	conf.cpp	/^void parse (int &n, const Json::Value &json) {$/;"	f
parse	conf.cpp	/^void parse (string &s, const Json::Value &json) {$/;"	f
parse_attach_handle	conf.cpp	/^void parse_attach_handle(vector<Handle*> &hans, const Json::Value &json,$/;"	f
parse_circle_handle	conf.cpp	/^void parse_circle_handle (vector<Handle*> &hans, const Json::Value &json,$/;"	f
parse_glue_handle	conf.cpp	/^void parse_glue_handle (vector<Handle*> &hans, const Json::Value &json,$/;"	f
parse_handle	conf.cpp	/^void parse_handle (vector<Handle*> &hans, const Json::Value &json,$/;"	f
parse_handles	conf.cpp	/^void parse_handles (vector<Handle*> &hans, const Json::Value &jsons,$/;"	f
parse_morph	conf.cpp	/^void parse_morph (Morph &morph, const Json::Value &json,$/;"	f
parse_morphs	conf.cpp	/^void parse_morphs (vector<Morph> &morphs, const Json::Value &json,$/;"	f
parse_motions	conf.cpp	/^void parse_motions (vector<Motion> &motions, const Json::Value &json) {$/;"	f
parse_node_handle	conf.cpp	/^void parse_node_handle (vector<Handle*> &hans, const Json::Value &json,$/;"	f
parse_obstacle	conf.cpp	/^void parse_obstacle (Obstacle &obstacle, const Json::Value &json,$/;"	f
parse_obstacles	conf.cpp	/^void parse_obstacles (vector<Obstacle> &obstacles, const Json::Value &json,$/;"	f
perp	vectors.hpp	/^template <typename T> Vec<2,T> perp (const Vec<2,T> &u) {return Vec<2,T>(-u[1],u[0]);}$/;"	f
points	spline.hpp	/^	std::vector<Point> points;$/;"	m	class:Spline
pop_cloth_gpu	gpu.cpp	/^void pop_cloth_gpu(Simulation &sim)$/;"	f
pop_mesh_gpu	gpu.cpp	/^void pop_mesh_gpu(Mesh &mesh)$/;"	f
pos	geometry.cpp	/^template <> Vec3 &pos<PS>(Node *node) { return node->y; }$/;"	f
pos	geometry.cpp	/^template <> Vec3 &pos<WS>(Node *node) { return node->x; }$/;"	f
pos	geometry.cpp	/^template <> const Vec3 &pos<PS>(const Node *node) { return node->y; }$/;"	f
pos	geometry.cpp	/^template <> const Vec3 &pos<WS>(const Node *node) { return node->x; }$/;"	f
pos	mot_parser.hpp	/^	Vec3 pos;$/;"	m	struct:BodyFrame
pos	separateobs.cpp	/^Vec3 pos (const Face *face, const Bary &b) {$/;"	f	namespace:SO
pos	spline.cpp	/^T Spline<T>::pos (REAL t) const {$/;"	f	class:Spline
precompute	auglag.hpp	/^    virtual void precompute (const double *x) const {}$/;"	f	struct:NLOpt
precompute	collision.cpp	/^void gNormalOpt::precompute(const double *x) const {$/;"	f	class:gNormalOpt
precompute	optimization.hpp	/^	virtual void precompute(const double *x) const {}$/;"	f	struct:NLConOpt
precompute	optimization.hpp	/^    virtual void precompute (const REAL *x) const {}$/;"	f	struct:NLOpt
precompute	popfilter.cpp	/^void PopOpt::precompute (const REAL *x) const {$/;"	f	class:PopOpt
precompute	strainlimiting.cpp	/^void SLOpt::precompute (const double *x) const {$/;"	f	class:SLOpt
prepare	simulation.cpp	/^void prepare(Simulation &sim)$/;"	f
preserve	mesh.hpp	/^	bool preserve; \/\/ don't remove this node$/;"	m	struct:Node
preserve_creases	magic.hpp	/^	bool preserve_creases;$/;"	m	struct:Magic
print	collision.cpp	/^	void print() {$/;"	f	struct:g_impact
print	collision.cpp	/^	void print() {$/;"	f	struct:g_impactZone
print	collision.cpp	/^	void print() {$/;"	f	struct:tmImpactInfo
print	tmbvh.hpp	/^	void print(FILE *fp) {$/;"	f	class:aabb
printLight	main.cpp	/^void printLight()$/;"	f
printTime	timer.hpp	/^	void printTime(std::string msg = std::string()) {$/;"	f	struct:GPUTimer2
problem	auglag.cpp	/^static const NLConOpt *problem;$/;"	v	file:
project	constraint.cpp	/^MeshGrad EqCon::project () {return MeshGrad();}$/;"	f	class:EqCon
project	constraint.cpp	/^MeshGrad GlueCon::project () {return MeshGrad();}$/;"	f	class:GlueCon
project	constraint.cpp	/^MeshGrad IneqCon::project () {$/;"	f	class:IneqCon
project	vectors.hpp	/^template <int m, int n, typename T> Vec<m,T> project (const VecnT &u) {Vec<m,T> v; for (int i = 0; i < m; i++) v[i] = (i<n) ? u[i] : 0; return v;}$/;"	f
project	vectors.hpp	/^template <int m1, int n1, int m2, int n2, typename T> Mat<m1,n1,T> project (const Mat<m2,n2,T> &A) {Mat<m1,n1,T> B; for (int j = 0; j < n1; j++) B.col(j) = (j<n2) ? project<m1>(A.col(j)) : Vec<m1,T>(0); return B;}$/;"	f
projection_thickness	magic.hpp	/^	REAL repulsion_thickness, projection_thickness;$/;"	m	struct:Magic
ptCloth	tmbvh.cpp	/^static vector<Mesh *>  *ptCloth;$/;"	v	file:
push2GPU	tmbvh.cpp	/^front_list::push2GPU(bvh_node *r1, bvh_node *r2 )$/;"	f	class:front_list
push2GPU	tmbvh.cpp	/^void bvh::push2GPU(bool isCloth)$/;"	f	class:bvh
push_cloth_gpu	gpu.cpp	/^void push_cloth_gpu(int idx, Cloth &c)$/;"	f
push_data_gpu	gpu.cpp	/^void push_data_gpu(Simulation &sim)$/;"	f
push_material_gpu	gpu.cpp	/^void push_material_gpu(const std::vector<Cloth> &c, const void *w, const void *g)$/;"	f
push_mesh_gpu	gpu.cpp	/^void push_mesh_gpu(Mesh &mesh, int mtrNum)$/;"	f
push_node_data	collision.cpp	/^void push_node_data(vector<g_impactNode> &nodes, REAL mrt)$/;"	f
push_node_gpu	gpu.cpp	/^void push_node_gpu(Mesh &mesh, REAL dt)$/;"	f
push_node_gpu	gpu.cpp	/^void push_node_gpu(int idx, Cloth &c, REAL dt)$/;"	f
push_node_vel	collision.cpp	/^void push_node_vel(vector<g_impactNode> &nodes, REAL dt)$/;"	f
push_nodes_gpu	gpu.cpp	/^void push_nodes_gpu(Simulation &sim)$/;"	f
push_obstacle_gpu	gpu.cpp	/^void push_obstacle_gpu(int idx, Obstacle &o)$/;"	f
quit	main.cpp	/^void quit()$/;"	f
quitModel	main.cpp	/^void quitModel()$/;"	f
read_motion_file	mot_parser.cpp	/^BodyVector read_motion_file(const string& filename) {$/;"	f
read_motion_file	mot_parser.cpp	/^BodyVector read_motion_file(std::istream& istr) {$/;"	f
reference_angle	mesh.hpp	/^	REAL reference_angle; \/\/ just to get sign of dihedral_angle() right$/;"	m	struct:Edge
refine_angle	cloth.hpp	/^		REAL refine_angle, refine_compression, refine_velocity;$/;"	m	struct:Cloth::Remeshing
refine_compression	cloth.hpp	/^		REAL refine_angle, refine_compression, refine_velocity;$/;"	m	struct:Cloth::Remeshing
refine_velocity	cloth.hpp	/^		REAL refine_angle, refine_compression, refine_velocity;$/;"	m	struct:Cloth::Remeshing
refit	tmbvh.cpp	/^bvh_node::refit(bool bound)$/;"	f	class:bvh_node
refit	tmbvh.cpp	/^void bvh::refit(bool bound)$/;"	f	class:bvh
relax_initial_state	equilibration.cpp	/^void relax_initial_state(Simulation &sim) {$/;"	f
remeshing	cloth.hpp	/^	} remeshing;$/;"	m	struct:Cloth	typeref:struct:Cloth::Remeshing
remove	mesh.cpp	/^void Mesh::remove (Edge *edge) {$/;"	f	class:Mesh
remove	mesh.cpp	/^void Mesh::remove (Face* face) {$/;"	f	class:Mesh
remove	mesh.cpp	/^void Mesh::remove (Node* node) {$/;"	f	class:Mesh
remove	mesh.cpp	/^void Mesh::remove (Vert* vert) {$/;"	f	class:Mesh
remove	util.hpp	/^template <typename T> inline void remove(int i, std::vector<T> &xs) {$/;"	f
reorder	tmbvh.cpp	/^void bvh::reorder()$/;"	f	class:bvh
replace	util.hpp	/^inline void replace(const T &x0, const T &x1, std::vector<T> &xs) {$/;"	f
replace	util.hpp	/^template <typename T> inline void replace(const T &v0, const T &v1, T vs[3]) {$/;"	f
repulsion_thickness	magic.hpp	/^	REAL repulsion_thickness, projection_thickness;$/;"	m	struct:Magic
reset	simulation.cpp	/^void Simulation::reset()$/;"	f	class:Simulation
reset	timer.hpp	/^	void reset() {$/;"	f	struct:GPUTimer2
reset	timer.hpp	/^	void reset(std::string msg) {$/;"	f	struct:GPUTimer2
resetParents	tmbvh.cpp	/^bvh_node::resetParents(bvh_node *root)$/;"	f	class:bvh_node
resetParents	tmbvh.cpp	/^void bvh::resetParents()$/;"	f	class:bvh
resize	main.cpp	/^void resize(int w, int h)$/;"	f
resize	mot_parser.cpp	/^void resize(BodyVector &bodies, size_t nbodies, size_t nframes) {$/;"	f
resume	handle.hpp	/^	void resume(vector<Mesh *>&ms) {$/;"	f	struct:AttachHandle
resume	handle.hpp	/^	void resume(vector<Mesh *>&ms) {$/;"	f	struct:CircleHandle
resume	handle.hpp	/^	void resume(vector<Mesh *>&ms) {$/;"	f	struct:GlueHandle
resume	handle.hpp	/^	void resume(vector<Mesh *>&ms) {$/;"	f	struct:NodeHandle
ret	main.cpp	/^static bool ret = false;$/;"	v	file:
rib_stiffening	magic.hpp	/^	REAL rib_stiffening;$/;"	m	struct:Magic
right	tmbvh.hpp	/^	FORCEINLINE bvh_node *right() { return this - _child + 1; }$/;"	f	class:bvh_node
root	tmbvh.hpp	/^	bvh_node *root() { return _nodes; }$/;"	f	class:bvh
rotate	transformation.cpp	/^Vec3 Quaternion::rotate (const Vec3 &x) const {$/;"	f	class:Quaternion
rotation	transformation.hpp	/^	Quaternion rotation;$/;"	m	struct:Transformation
row	vectors.hpp	/^    VecnT row (int i) const {VecnT R; for(int col = 0; col < n; ++col) { R[col] = c[col][i]; } return R; }$/;"	f	class:Mat
rows	sparse.hpp	/^    std::vector< SpVec<T> > rows;$/;"	m	struct:SpMat
rows	vectors.hpp	/^	static Mat rows (VecnT x, VecnT y) { Mat<2,n,T> M; for(int i = 0; i < n; i++) { M.col(i)[0] = x[i]; M.col(i)[1] = y[i]; } return M; }$/;"	f	class:Mat
rows	vectors.hpp	/^    static Mat rows (VecnT x, VecnT y, VecnT z) { Mat<3,n,T> M; for(int i = 0; i < n; i++) { M.col(i)[0] = x[i]; M.col(i)[1] = y[i]; M.col(i)[2] = z[i];} return M; }$/;"	f	class:Mat
rows	vectors.hpp	/^    static Mat rows (VecnT x, VecnT y, VecnT z, VecnT w) { Mat<4,n,T> M; for(int i = 0; i < n; i++) { M.col(i)[0] = x[i]; M.col(i)[1] = y[i]; M.col(i)[2] = z[i]; M.col(i)[3] = w[i];} return M; }$/;"	f	class:Mat
s	dde.hpp	/^struct StretchingSamples { Vec4 s[40][40][40]; };$/;"	m	struct:StretchingSamples
s	strainlimiting.cpp	/^    mutable vector<double> s;$/;"	m	struct:SLOpt	file:
s	transformation.hpp	/^	REAL s;$/;"	m	struct:Quaternion
s	vectors.hpp	/^    Vec<n> s;$/;"	m	struct:SVD
s_current	tmbvh.cpp	/^static bvh_node *s_current;$/;"	v	file:
s_fboxes	tmbvh.cpp	/^static BOX *s_fboxes;$/;"	v	file:
s_fcenters	tmbvh.cpp	/^static vec3f *s_fcenters;$/;"	v	file:
s_idx_buffer	tmbvh.cpp	/^static unsigned int *s_idx_buffer;$/;"	v	file:
s_nidx	tmbvh.cpp	/^static vec3i *s_nidx;$/;"	v	file:
save	save.cpp	/^static void save(const vector<Mesh*> &meshes, int frame) {$/;"	f	file:
save	save.cpp	/^void save(const Simulation &sim, int frame)$/;"	f
save_gpu	save.cpp	/^static void save_gpu(const vector<Mesh*> &meshes, int frame) {$/;"	f	file:
save_gpu	save.cpp	/^void save_gpu(const Simulation &sim, int frame)$/;"	f
save_obj	io.cpp	/^void save_obj(const Mesh &mesh, const string &filename) {$/;"	f
save_objs	io.cpp	/^void save_objs(const vector<Mesh*> &meshes, const string &prefix) {$/;"	f
save_obstacle_transforms	save.cpp	/^static void save_obstacle_transforms(const vector<Obstacle> &obs, int frame,$/;"	f	file:
save_png	io.cpp	/^void save_png(const char *filename, int width, int height,$/;"	f
save_screenshot	io.cpp	/^void save_screenshot(const string &filename) {$/;"	f
save_transformation	io.cpp	/^void save_transformation(const Transformation &tr, const string &filename) {$/;"	f
scale	transformation.hpp	/^	REAL scale;$/;"	m	struct:Transformation
self_collide	tmbvh.hpp	/^	void self_collide(front_list &f, vector<Mesh *> &c) {$/;"	f	class:bvh
self_collide	tmbvh.hpp	/^	void self_collide(front_list &lst, bvh_node *r) {$/;"	f	class:bvh_node
self_mesh	tmbvh.cpp	/^void self_mesh(vector<Mesh *> &meshes)$/;"	f
separate_obstacles	separateobs.cpp	/^void separate_obstacles (vector<Mesh*> &obs_meshes,$/;"	f
separate_obstacles	separateobs.cpp	/^void separate_obstacles (vector<Mesh*> &obs_meshes,$/;"	f	namespace:SO
set	gpu.cpp	/^	FORCEINLINE void set(unsigned int id0, unsigned int id1, unsigned int id2) {$/;"	f	class:tri3f
setParent	tmbvh.hpp	/^	void setParent(int p) { _parent = p; }$/;"	f	class:bvh_node
set_submat	popfilter.cpp	/^static void set_submat (SpMat<REAL> &A, int i, int j, const Mat3x3 &Aij) {$/;"	f	file:
set_subvec	auglag.hpp	/^inline void set_subvec (double *x, int i, const Vec3 &xi) {$/;"	f
set_subvec	optimization.hpp	/^inline void set_subvec(double *x, int i, const Vec3 &xi) {$/;"	f
set_subvec	optimization.hpp	/^template <int n> void set_subvec (double *x, int i, const Vec<n> &xi) {$/;"	f
set_value	gpu.cpp	/^	FORCEINLINE vec3f & set_value(const double &vx, const double &vy, const double &vz)$/;"	f	class:vec3f
set_x	collision.cpp	/^inline void set_x(uint n, bool f, Vec3 v)$/;"	f
sg	strainlimiting.cpp	/^    mutable vector<Mat3x3> sg;$/;"	m	struct:SLOpt	file:
sgn	util.hpp	/^template <typename T> T sgn(const T &x) { return x<0 ? -1 : 1; }$/;"	f
sim	simulation.cpp	/^Simulation sim;$/;"	v
sim_step_gpu	simulation.cpp	/^bool sim_step_gpu()$/;"	f
singular_value_decomposition	vectors.cpp	/^template <int m, int n> SVD<m,n> singular_value_decomposition (const Mat<m,n> &A) {$/;"	f
singular_value_decomposition	vectors.cpp	/^template<> SVD<3,2> singular_value_decomposition<3,2> (const Mat<3,2> &A) {$/;"	f
size	simulation.cpp	/^template <typename Prim> int size(const vector<Mesh*> &meshes) {$/;"	f
size_max	cloth.hpp	/^		REAL size_min, size_max; \/\/ size limits$/;"	m	struct:Cloth::Remeshing
size_min	cloth.hpp	/^		REAL size_min, size_max; \/\/ size limits$/;"	m	struct:Cloth::Remeshing
sizing	mesh.hpp	/^	Sizing *sizing;$/;"	m	struct:Vert
snprintf	winport.hpp	23;"	d
solve_ixns	separateobs.cpp	/^void solve_ixns (const vector<Ixn> &ixns) {$/;"	f	namespace:SO
solve_quadratic	util.cpp	/^int solve_quadratic(REAL a, REAL b, REAL c, REAL x[2]) {$/;"	f
sparse_to_eigen	eigen.cpp	/^sparse_to_eigen(const SpMat<REAL> &As, EigenSpMat &Ae, int n)$/;"	f
sq	vectors.hpp	/^inline REAL sq (REAL x) {return x*x;}$/;"	f
sqrt	winport.hpp	/^inline double sqrt(int n) { return sqrt(double(n)); }$/;"	f
squareLength	gpu.cpp	/^	FORCEINLINE double squareLength() const {$/;"	f	class:vec3f
stFrame	main.cpp	/^int stFrame = 0;$/;"	v
start	timer.hpp	/^	cudaEvent_t start, stop;$/;"	m	struct:GPUTimer2
start_time	handle.hpp	/^	REAL start_time, end_time, fade_time;$/;"	m	struct:Handle
start_time	obstacle.hpp	/^	REAL start_time, end_time;$/;"	m	struct:Obstacle
static_assert	vectors.hpp	270;"	d
static_assert	vectors.hpp	47;"	d
static_assertion_failure	vectors.hpp	/^template <> struct static_assertion_failure<true> {void operator() () {}};$/;"	s
step	simulation.hpp	/^	int frame, step;$/;"	m	struct:Simulation
step_mesh	gpu.cpp	/^void step_mesh(Mesh &mesh, REAL dt) {$/;"	f
step_time	simulation.hpp	/^	REAL frame_time, step_time;$/;"	m	struct:Simulation
stiff	constraint.hpp	/^	REAL stiff;$/;"	m	struct:EqCon
stiff	constraint.hpp	/^	REAL stiff;$/;"	m	struct:GlueCon
stiff	constraint.hpp	/^	REAL stiff;$/;"	m	struct:IneqCon
stop	timer.hpp	/^	cudaEvent_t start, stop;$/;"	m	struct:GPUTimer2
stp	vectors.hpp	/^template <typename T> T stp (const Vec<3,T> &u, const Vec<3,T> &v, const Vec<3,T> &w) {return dot(u,cross(v,w));}$/;"	f
strain_con	strainlimiting.cpp	/^REAL strain_con (const SLOpt &sl, const double *x, int j, int &sign) {$/;"	f
strain_con_grad	strainlimiting.cpp	/^void strain_con_grad (const SLOpt &sl, const double *x, int j, double factor,$/;"	f
strain_limiting	strainlimiting.cpp	/^void strain_limiting$/;"	f
strain_limiting_jaccobi	strainlimiting.cpp	/^void strain_limiting_jaccobi$/;"	f
strain_limiting_opt	strainlimiting.cpp	/^void strain_limiting_opt$/;"	f
strain_limits	strainlimiting.cpp	/^    const vector<Vec2> &strain_limits;$/;"	m	struct:SLOpt	file:
strain_max	cloth.hpp	/^		REAL strain_min, strain_max; \/\/ strain limits$/;"	m	struct:Cloth::Material
strain_min	cloth.hpp	/^		REAL strain_min, strain_max; \/\/ strain limits$/;"	m	struct:Cloth::Material
strength	handle.hpp	/^	REAL strength(REAL t) {$/;"	f	struct:Handle
stretching	cloth.hpp	/^		StretchingSamples stretching;$/;"	m	struct:Cloth::Material
stretching_stiffness	dde.cpp	/^Vec4 stretching_stiffness (const Mat2x2 &G, const StretchingSamples &samples) {$/;"	f
subset	util.hpp	/^inline bool subset(const std::vector<T> &xs, const std::vector<T> &ys) {$/;"	f
symmetrize	blockvectors.hpp	/^template <> inline Mat<3, 4> symmetrize<2>() {$/;"	f
t	spline.hpp	/^	struct Point { REAL t; T x, v; };$/;"	m	struct:Spline::Point
t	vectors.hpp	/^    MatnmT t () const {return transpose(*this);}$/;"	f	class:Mat
t	vectors.hpp	/^    const Mat<m,n,T>& t () const {return static_cast<const Mat<m, n, T>&>(*this);}$/;"	f	class:MatTransposed
targets	morph.hpp	/^	std::vector<Mesh> targets;$/;"	m	struct:Morph
then	timer.hpp	/^	boost::posix_time::ptime then;$/;"	m	struct:Timer
then	timer.hpp	/^	double last, total, then;$/;"	m	struct:Timer
theta	mesh.hpp	/^	REAL theta; \/\/ actual dihedral angle$/;"	m	struct:Edge
theta_ideal	mesh.hpp	/^	REAL theta_ideal, damage; \/\/ rest dihedral angle, damage parameter$/;"	m	struct:Edge
thickness	collision.cpp	/^static const REAL &thickness = ::magic.projection_thickness;$/;"	v	file:
tick	timer.cpp	/^void Timer::tick() {$/;"	f	class:Timer
tick	timer.hpp	/^	void tick() {$/;"	f	struct:GPUTimer2
tidx	gpu.cpp	/^static int tidx;$/;"	v	file:
time	simulation.hpp	/^	REAL time;$/;"	m	struct:Simulation
timers	simulation.hpp	/^	Timer timers[nModules];$/;"	m	struct:Simulation
tmImpactInfo	collision.cpp	/^struct tmImpactInfo {$/;"	s	file:
tm_iterations	magic.hpp	/^	int tm_iterations;$/;"	m	struct:Magic
tm_jacobi_preconditioner	magic.hpp	/^	bool tm_jacobi_preconditioner;$/;"	m	struct:Magic
tm_load_ob	magic.hpp	/^	int tm_load_ob;$/;"	m	struct:Magic
tm_output_file	magic.hpp	/^	bool tm_output_file;$/;"	m	struct:Magic
tm_self_cd	magic.hpp	/^	bool tm_self_cd;$/;"	m	struct:Magic
tm_strain_limiting	magic.hpp	/^	bool tm_strain_limiting;$/;"	m	struct:Magic
tm_use_gpu	magic.hpp	/^	bool tm_use_gpu;$/;"	m	struct:Magic
tm_with_cd	magic.hpp	/^	bool tm_with_cd;$/;"	m	struct:Magic
tm_with_ti	magic.hpp	/^	bool tm_with_ti;$/;"	m	struct:Magic
to_axisangle	transformation.cpp	/^pair<Vec3, REAL> Quaternion::to_axisangle() const {$/;"	f	class:Quaternion
tock	timer.cpp	/^void Timer::tock() {$/;"	f	class:Timer
tock	timer.hpp	/^	float tock(std::string msg) {$/;"	f	struct:GPUTimer2
tock	timer.hpp	/^	void tock() {$/;"	f	struct:GPUTimer2
tock2	timer.cpp	/^double Timer::tock2() {$/;"	f	class:Timer
tock2	timer.hpp	/^	float tock2() {$/;"	f	struct:GPUTimer2
total	timer.hpp	/^	double last, total, then;$/;"	m	struct:Timer
totalVert	gpu.cpp	/^vector<Vec3> totalVert;$/;"	v
tpl	vectors.hpp	110;"	d
tpl	vectors.hpp	116;"	d
tpl	vectors.hpp	183;"	d
tpl	vectors.hpp	49;"	d
trace	vectors.hpp	/^template <int n, typename T> T trace (const MatnnT &A) {T t = 0; for (int j = 0; j < n; j++) t += A(j,j); return t;}$/;"	f
transform_spline	obstacle.hpp	/^	const Motion *transform_spline;$/;"	m	struct:Obstacle
translation	transformation.hpp	/^	Vec3 translation;$/;"	m	struct:Transformation
transpose	blockvectors.hpp	/^template <int m, int n> Mat<m*n, m*n, REAL> transpose() {$/;"	f
transpose	vectors.hpp	/^tpl MatnmT transpose (const MatmnT &A) {MatnmT B; for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) B(j,i) = A(i,j); return B;}$/;"	f
tri3f	gpu.cpp	/^	FORCEINLINE tri3f() {$/;"	f	class:tri3f
tri3f	gpu.cpp	/^	FORCEINLINE tri3f(unsigned int id0, unsigned int id1, unsigned int id2) {$/;"	f	class:tri3f
tri3f	gpu.cpp	/^class tri3f {$/;"	c	file:
triID	tmbvh.hpp	/^	FORCEINLINE int triID() { return _child; }$/;"	f	class:bvh_node
triangulate	io.cpp	/^vector<Face*> triangulate(const vector<Vert*> &verts) {$/;"	f
u	handle.hpp	/^	Vec2 u;$/;"	m	struct:CircleHandle
u	mesh.hpp	/^	Vec2 u; \/\/ material space$/;"	m	struct:Vert
uint	util.hpp	/^typedef unsigned int uint;$/;"	t
umax	conf.cpp	/^    Vec2 umin, umax;$/;"	m	struct:Box	file:
umin	conf.cpp	/^    Vec2 umin, umax;$/;"	m	struct:Box	file:
unwrap_angle	geometry.cpp	/^REAL unwrap_angle(REAL theta, REAL theta_ref) {$/;"	f
update	tmbvh.hpp	/^	void update (front_list &appended) {$/;"	f	class:front_node
updateFPS	main.cpp	/^void updateFPS()$/;"	f
updateLight	main.cpp	/^void updateLight()$/;"	f
update_active	separateobs.cpp	/^void update_active (const vector<AccelStruct*> &accs, const vector<Ixn> &ixns) {$/;"	f	namespace:SO
update_indices	mesh.cpp	/^void update_indices (Mesh &mesh) {$/;"	f
update_mesh_gpu	gpu.cpp	/^void update_mesh_gpu(int idx, Mesh &mesh)$/;"	f
update_obstacle_gpu	gpu.cpp	/^void update_obstacle_gpu(int idx, Obstacle &o)$/;"	f
update_obstacles	gpu.cpp	/^void update_obstacles(Simulation &sim, bool update_positions) {$/;"	f
update_obstacles_gpu	gpu.cpp	/^void update_obstacles_gpu(Simulation &sim)$/;"	f
update_x0	mesh.cpp	/^void update_x0 (Mesh &mesh) {$/;"	f
v	conf.cpp	/^struct Velocity {Vec3 v, w; Vec3 o;};$/;"	m	struct:Velocity	file:
v	gpu.cpp	/^			double v[3];$/;"	m	struct:vec3f::__anon2::__anon4	file:
v	mesh.hpp	/^	Vec3 x, x0, v; \/\/ position, old (collision-free) position, velocity$/;"	m	struct:Node
v	mesh.hpp	/^	Vert* v[3]; \/\/ verts$/;"	m	struct:Face
v	spline.hpp	/^	struct Point { REAL t; T x, v; };$/;"	m	struct:Spline::Point
v	transformation.hpp	/^	Vec3 v;$/;"	m	struct:Quaternion
validate_handles	equilibration.cpp	/^void validate_handles(const Simulation &sim) {$/;"	f
value	constraint.cpp	/^REAL EqCon::value (int *sign) {$/;"	f	class:EqCon
value	constraint.cpp	/^REAL GlueCon::value (int *sign) {$/;"	f	class:GlueCon
value	constraint.cpp	/^REAL IneqCon::value (int *sign) {$/;"	f	class:IneqCon
vec3f	gpu.cpp	/^	FORCEINLINE vec3f()$/;"	f	class:vec3f
vec3f	gpu.cpp	/^	FORCEINLINE vec3f(const double *v)$/;"	f	class:vec3f
vec3f	gpu.cpp	/^	FORCEINLINE vec3f(const vec3f &v)$/;"	f	class:vec3f
vec3f	gpu.cpp	/^	FORCEINLINE vec3f(double x, double y, double z)$/;"	f	class:vec3f
vec3f	gpu.cpp	/^class vec3f {$/;"	c	file:
vec3f	tmbvh.hpp	/^typedef Vec3 vec3f;$/;"	t
vec3i	tmbvh.hpp	/^typedef Vec<3, int> vec3i;$/;"	t
vec_to_mat	blockvectors.hpp	/^Mat<m, n, T> vec_to_mat(const Vec<m*n, T> &a) {$/;"	f
vel	spline.cpp	/^T Spline<T>::vel (REAL t) const {$/;"	f	class:Spline
velocity	simulation.hpp	/^	Vec3 velocity;$/;"	m	struct:Wind
vertex	simulation.cpp	/^void vertex(const Vec3 &x) {$/;"	f
verts	mesh.hpp	/^	std::vector<Vert*> verts;$/;"	m	struct:Mesh
verts	mesh.hpp	/^	std::vector<Vert*> verts;$/;"	m	struct:Node
vf_clear_distance	separateobs.cpp	/^REAL vf_clear_distance (const Face *face0, const Face *face1, const Vec3 &d,$/;"	f	namespace:SO
violation	constraint.cpp	/^REAL violation(REAL value) { return std::fmax(-value, REAL(0.)); }$/;"	f
visualize	tmbvh.cpp	/^bvh_node::visualize(int level)$/;"	f	class:bvh_node
visualize	tmbvh.cpp	/^contour::visualize(bool spec)$/;"	f	class:contour
visualizeBound	tmbvh.cpp	/^bvh_node::visualizeBound(bool spec)$/;"	f	class:bvh_node
visualize_cones	gpu.cpp	/^void visualize_cones()$/;"	f
visualize_cones	gpu.cpp	/^void visualize_cones(Simulation &sim)$/;"	f
vmax	tmbvh.hpp	/^vmax(vec3f &a, const vec3f &b)$/;"	f
vmin	tmbvh.hpp	/^vmin(vec3f &a, const vec3f &b)$/;"	f
volume	tmbvh.hpp	/^	FORCEINLINE REAL volume() const { return width()*height()*depth(); }$/;"	f	class:aabb
w	conf.cpp	/^struct Velocity {Vec3 v, w; Vec3 o;};$/;"	m	struct:Velocity	file:
w	constraint.hpp	/^	REAL w[4];$/;"	m	struct:IneqCon
weakening	cloth.hpp	/^		REAL yield_curv, weakening; \/\/ plasticity parameters$/;"	m	struct:Cloth::Material
wedge	vectors.hpp	/^template <typename T> T wedge (const Vec<2,T> &u, const Vec<2,T> &v) {return u[0]*v[1] - u[1]*v[0];}$/;"	f
weights	morph.hpp	/^	Spline<Weights> weights;$/;"	m	struct:Morph
width	tmbvh.hpp	/^	FORCEINLINE REAL width()  const { return _max[0] - _min[0]; }$/;"	f	class:aabb
win_h	main.cpp	/^int win_w = 512, win_h = 512;$/;"	v
win_w	main.cpp	/^int win_w = 512, win_h = 512;$/;"	v
wind	simulation.hpp	/^	Wind wind;$/;"	m	struct:Simulation
write_motion_file	mot_parser.cpp	/^void write_motion_file(BodyVector &bodies, const string& filename) {$/;"	f
write_motion_file	mot_parser.cpp	/^void write_motion_file(BodyVector &bodies, ostream& ostr) {$/;"	f
x	constraint.hpp	/^	Vec3 x, n;$/;"	m	struct:EqCon
x	gpu.cpp	/^			double x, y, z;$/;"	m	struct:vec3f::__anon2::__anon3	file:
x	mesh.hpp	/^	Vec3 x, x0, v; \/\/ position, old (collision-free) position, velocity$/;"	m	struct:Node
x	spline.hpp	/^	struct Point { REAL t; T x, v; };$/;"	m	struct:Spline::Point
x0	handle.hpp	/^	Vec3 x0;$/;"	m	struct:NodeHandle
x0	mesh.hpp	/^	Vec3 x, x0, v; \/\/ position, old (collision-free) position, velocity$/;"	m	struct:Node
x0	popfilter.cpp	/^    vector<Vec3> x0, a0;$/;"	m	struct:PopOpt	file:
xAxis	gpu.cpp	/^	static vec3f xAxis() { return vec3f(1.f, 0.f, 0.f); }$/;"	f	class:vec3f
xc	handle.hpp	/^	Vec3 xc, dx0, dx1;$/;"	m	struct:CircleHandle
xold	collision.cpp	/^static vector<Vec3> xold;$/;"	v	file:
xold	separateobs.cpp	/^static vector<Vec3> xold;$/;"	m	namespace:SO	file:
xold	strainlimiting.cpp	/^    vector<Vec3> xold;$/;"	m	struct:SLOpt	file:
xold_obs	collision.cpp	/^static vector<Vec3> xold_obs;$/;"	v	file:
y	gpu.cpp	/^			double x, y, z;$/;"	m	struct:vec3f::__anon2::__anon3	file:
y	mesh.hpp	/^	Vec3 y; \/\/ plastic embedding$/;"	m	struct:Node
yAxis	gpu.cpp	/^	static vec3f yAxis() { return vec3f(0.f, 1.f, 0.f); }$/;"	f	class:vec3f
yield_curv	cloth.hpp	/^		REAL yield_curv, weakening; \/\/ plasticity parameters$/;"	m	struct:Cloth::Material
z	gpu.cpp	/^			double x, y, z;$/;"	m	struct:vec3f::__anon2::__anon3	file:
zAxis	gpu.cpp	/^	static vec3f zAxis() { return vec3f(0.f, 0.f, 1.f); }$/;"	f	class:vec3f
zero	gpu.cpp	/^	static vec3f zero() {$/;"	f	class:vec3f
~Constraint	constraint.hpp	/^	virtual ~Constraint() {};$/;"	f	struct:Constraint
~GPUTimer2	timer.hpp	/^	~GPUTimer2() {$/;"	f	struct:GPUTimer2
~Handle	handle.hpp	/^	virtual ~Handle() {};$/;"	f	struct:Handle
~Mesh	mesh.hpp	/^	~Mesh() {$/;"	f	struct:Mesh
~bvh	tmbvh.hpp	/^	~bvh() {$/;"	f	class:bvh
~bvh_node	tmbvh.hpp	/^	~bvh_node() {$/;"	f	class:bvh_node
